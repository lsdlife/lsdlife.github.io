<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL的相关知识 | lsd</title><meta name="author" content="lsd"><meta name="copyright" content="lsd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. SQL语句分类根据其功能，主要分为四类：    分 类 全称 说明    DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表， 字段)   DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改   DQL Data Query Language 数据查询语言，用来查询数据库中表的记录">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL的相关知识">
<meta property="og:url" content="http://example.com/2022/11/18/MySQL%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="lsd">
<meta property="og:description" content="1. SQL语句分类根据其功能，主要分为四类：    分 类 全称 说明    DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表， 字段)   DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改   DQL Data Query Language 数据查询语言，用来查询数据库中表的记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-11-18T12:51:36.000Z">
<meta property="article:modified_time" content="2022-11-18T15:27:03.476Z">
<meta property="article:author" content="lsd">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/11/18/MySQL%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL的相关知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-18 23:27:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lsd</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL的相关知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-18T12:51:36.000Z" title="发表于 2022-11-18 20:51:36">2022-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-18T15:27:03.476Z" title="更新于 2022-11-18 23:27:03">2022-11-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL的相关知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-SQL语句分类"><a href="#1-SQL语句分类" class="headerlink" title="1. SQL语句分类"></a>1. SQL语句分类</h1><p>根据其功能，主要分为四类：</p>
<table>
<thead>
<tr>
<th>分 类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据定义语言，用来定义数据库对象(数据库，表， 字段)</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td>
</tr>
</tbody></table>
<h1 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询所有数据库：</span><br><span class="line">show databases ;</span><br><span class="line"></span><br><span class="line">#查询当前数据库：</span><br><span class="line">select database() ;</span><br><span class="line"></span><br><span class="line">#创建数据库：</span><br><span class="line">create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</span><br><span class="line">//create database itheima default charset utf8mb4;</span><br><span class="line"></span><br><span class="line">#删除数据库：</span><br><span class="line">drop database [ if exists ] 数据库名 ;</span><br><span class="line">#使用数据库：</span><br><span class="line">use 数据库名 ;</span><br><span class="line"></span><br><span class="line">#新建schema</span><br><span class="line">create schema db01;</span><br></pre></td></tr></table></figure>





<h1 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3 表操作"></a>3 表操作</h1><h2 id="3-1-添加数据"><a href="#3-1-添加数据" class="headerlink" title="3.1 添加数据"></a>3.1 添加数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询当前数据库所有表：</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">#查看指定表结构</span><br><span class="line">desc 表名 ;</span><br><span class="line"></span><br><span class="line">#创建表：</span><br><span class="line">CREATE TABLE 表名(    </span><br><span class="line">字段1 字段1类型 [COMMENT 字段1注释],    </span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释],   </span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释],  </span><br><span class="line">...    </span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br><span class="line">//</span><br><span class="line">create table tb_user(</span><br><span class="line">id int comment &#x27;编号&#x27;,</span><br><span class="line">name varchar(50) comment &#x27;姓名&#x27;,</span><br><span class="line">age int comment &#x27;年龄&#x27;,</span><br><span class="line">gender varchar(1) comment &#x27;性别&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br><span class="line"></span><br><span class="line">#查询指定表的建表语句：</span><br><span class="line">show create table 表名 ;</span><br><span class="line"></span><br><span class="line">#给指定字段添加数据</span><br><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...)</span><br><span class="line">#案例: 给employee表所有的字段添加数据 ；</span><br><span class="line">insert into employee(id,workno,name,gender,age,idcard,entrydate) values(1,&#x27;1&#x27;,&#x27;Itcast&#x27;,&#x27;男&#x27;,10,&#x27;123456789012345678&#x27;,&#x27;2000-01-01&#x27;);</span><br><span class="line"></span><br><span class="line">#给全部字段添加数据</span><br><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br><span class="line">案例：插入数据到employee表，具体的SQL如下：</span><br><span class="line">insert into employee values(2,&#x27;2&#x27;,&#x27;张无忌&#x27;,&#x27;男&#x27;,18,&#x27;123456789012345670&#x27;,&#x27;2005-01-</span><br><span class="line">01&#x27;);</span><br><span class="line"></span><br><span class="line">#批量添加数据</span><br><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值 1, 值2, ...) ;</span><br><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</span><br><span class="line">#案例：批量插入数据到employee表，具体的SQL如下：</span><br><span class="line">insert into employee values(3,&#x27;3&#x27;,&#x27;韦一笑&#x27;,&#x27;男&#x27;,38,&#x27;123456789012345670&#x27;,&#x27;2005-01-</span><br><span class="line">01&#x27;),(4,&#x27;4&#x27;,&#x27;赵敏&#x27;,&#x27;女&#x27;,18,&#x27;123456789012345670&#x27;,&#x27;2005-01-01&#x27;);</span><br></pre></td></tr></table></figure>



<h2 id="3-2-删除数据"><a href="#3-2-删除数据" class="headerlink" title="3.2 删除数据"></a>3.2 删除数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除表</span><br><span class="line">DROP TABLE [ IF EXISTS ] 表名</span><br><span class="line">#如果tb_user表存在，则删除tb_user表</span><br><span class="line">DROP TABLE IF EXISTS tb_user;</span><br><span class="line"></span><br><span class="line">#删除指定表, 并重新创建表</span><br><span class="line">TRUNCATE TABLE 表名</span><br><span class="line"></span><br><span class="line">#删除数据的具体语法为：</span><br><span class="line">DELETE FROM 表名 [ WHERE 条件 ] </span><br><span class="line"></span><br><span class="line">#删除gender为女的员工</span><br><span class="line">delete from employee where gender = &#x27;女&#x27;;</span><br><span class="line"></span><br><span class="line">#删除所有员工</span><br><span class="line">delete from employee</span><br></pre></td></tr></table></figure>



<h2 id="3-3-修改数据"><a href="#3-3-修改数据" class="headerlink" title="3.3 修改数据"></a>3.3 修改数据</h2><h3 id="3-3-1-alter"><a href="#3-3-1-alter" class="headerlink" title="3.3.1  alter"></a>3.3.1  alter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加字段</span><br><span class="line">ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="line"></span><br><span class="line">#为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20) </span><br><span class="line">ALTER TABLE emp ADD nickname varchar(20) COMMENT &#x27;昵称&#x27;;</span><br><span class="line"></span><br><span class="line">#修改数据类型</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度);</span><br><span class="line"></span><br><span class="line">#修改字段名和字段类型</span><br><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="line"></span><br><span class="line">#将emp表的nickname字段修改为username，类型为varchar(30)</span><br><span class="line">ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#x27;昵称&#x27;;</span><br><span class="line"></span><br><span class="line">#删除字段</span><br><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br><span class="line"></span><br><span class="line">#将emp表的字段username删除</span><br><span class="line">ALTER TABLE emp DROP username;</span><br><span class="line"></span><br><span class="line">#修改表名</span><br><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br><span class="line"></span><br><span class="line">#将emp表的表名修改为 employee</span><br><span class="line">ALTER TABLE emp RENAME TO employee;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-2-update"><a href="#3-3-2-update" class="headerlink" title="3.3.2  update"></a>3.3.2  update</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改数据的具体语法为:</span><br><span class="line">UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</span><br><span class="line"></span><br><span class="line">#修改id为1的数据，将name修改为itheima</span><br><span class="line">update employee set name = &#x27;itheima&#x27; where id = 1;</span><br><span class="line"></span><br><span class="line">#修改id为1的数据, 将name修改为小昭, gender修改为 女</span><br><span class="line">update employee set name = &#x27;小昭&#x27; , gender = &#x27;女&#x27; where id = 1;</span><br><span class="line"></span><br><span class="line">#将所有的员工入职日期修改为 2008-01-01</span><br><span class="line">update employee set entrydate = &#x27;2008-01-01&#x27;;</span><br></pre></td></tr></table></figure>





<h2 id="3-4-单表查询"><a href="#3-4-单表查询" class="headerlink" title="3.4 单表查询"></a>3.4 单表查询</h2><h3 id="3-4-1-基本查询"><a href="#3-4-1-基本查询" class="headerlink" title="3.4.1 基本查询"></a>3.4.1 基本查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">基础查询</span><br><span class="line"></span><br><span class="line">#查询多个字段</span><br><span class="line">SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</span><br><span class="line"></span><br><span class="line">#字段设置别名</span><br><span class="line">SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</span><br><span class="line"></span><br><span class="line">#去除重复记录</span><br><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">聚合函数查询</span><br><span class="line"></span><br><span class="line">SELECT 聚合函数(字段列表) FROM 表名 ;</span><br><span class="line">//注意 : NULL值是不参与所有聚合函数运算的。</span><br><span class="line"></span><br><span class="line">#对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计 查询，比如：</span><br><span class="line">select count(1) from emp;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">分组查询</span><br><span class="line"></span><br><span class="line">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组</span><br><span class="line">后过滤条件 ];</span><br><span class="line">#查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*)  address_count from emp where age &lt; 45 group by</span><br><span class="line">workaddress having address_count &gt;= 3;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">分页查询</span><br><span class="line"></span><br><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h3 id="3-4-2-执行顺序"><a href="#3-4-2-执行顺序" class="headerlink" title="3.4.2 执行顺序"></a>3.4.2 执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DQL语句的执行顺序为： from ... where ... group by ... having ... select ... order by ... limit ...</span><br><span class="line"></span><br><span class="line">//where和having区别</span><br><span class="line">执行时机不同：where是分组前进行过滤，不满足where的不参与分组，having是分组之后对结果进行过滤</span><br><span class="line">判断条件不同：where不能对聚合函数进行判断，而having可以</span><br><span class="line">执行顺序: where &gt; 聚合函数 &gt; having 。</span><br><span class="line">支持多字段分组, 具体语法为 : group by columnA,columnB</span><br></pre></td></tr></table></figure>



<h3 id="3-4-3字符串类型"><a href="#3-4-3字符串类型" class="headerlink" title="3.4.3字符串类型"></a>3.4.3字符串类型</h3><p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//char 与 varchar:</span><br><span class="line">都可以描述字符串。</span><br><span class="line">char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。</span><br><span class="line">varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</span><br><span class="line"></span><br><span class="line">#concat : 字符串拼接 </span><br><span class="line">select concat(&#x27;Hello&#x27; , &#x27; MySQL&#x27;);</span><br><span class="line"></span><br><span class="line">#lower : 全部转小写 </span><br><span class="line">select lower(&#x27;Hello&#x27;);</span><br><span class="line"></span><br><span class="line">#upper : 全部转大写</span><br><span class="line">select upper(&#x27;Hello&#x27;);</span><br><span class="line"></span><br><span class="line">#lpad : 左填充 </span><br><span class="line">select lpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">#rpad : 右填充 </span><br><span class="line">select rpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">#trim : 去除空格 </span><br><span class="line">elect trim(&#x27; Hello MySQL &#x27;)</span><br><span class="line"></span><br><span class="line">#substring : 截取子字符串 </span><br><span class="line">select substring(&#x27;Hello MySQL&#x27;,1,5);</span><br></pre></td></tr></table></figure>





<h2 id="3-5-多表查询"><a href="#3-5-多表查询" class="headerlink" title="3.5. 多表查询"></a>3.5. 多表查询</h2><h3 id="3-5-1-多表关系"><a href="#3-5-1-多表关系" class="headerlink" title="3.5.1 多表关系"></a>3.5.1 多表关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一对多 (多对一) </span><br><span class="line">案例：一个部门对应多个员工，一个员工对应一个部门</span><br><span class="line">实现: 在多的一方建立外键，指向一的一方的主键</span><br><span class="line"></span><br><span class="line"># 5.1.2 多对多</span><br><span class="line">案例：一个学生可以选修多门课程，一门课程也可以供多个学生选择</span><br><span class="line">实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</span><br><span class="line"></span><br><span class="line"># 5.1.3 一对一</span><br><span class="line">案例: 用户 与 用户详情的关系</span><br><span class="line">实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</span><br></pre></td></tr></table></figure>



<h3 id="3-5-2-内连接"><a href="#3-5-2-内连接" class="headerlink" title="3.5.2 内连接"></a>3.5.2 内连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#内连接：相当于查询A、B交集部分数据</span><br><span class="line"></span><br><span class="line">#隐式内连接： </span><br><span class="line">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</span><br><span class="line">//select e.name,d.name from emp e , dept d where e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">#显式内连接</span><br><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</span><br><span class="line">//select e.name, d.name from emp e join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-3-外连接"><a href="#3-5-3-外连接" class="headerlink" title="3.5.3 外连接"></a>3.5.3 外连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#左外连接</span><br><span class="line">#左外连接：左表+交集</span><br><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br><span class="line">//select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">#右外连接</span><br><span class="line">#右外连接：右表+交集</span><br><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br><span class="line">//select d.*, e.* from emp e right  join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-4-自连接和联合查询"><a href="#3-5-4-自连接和联合查询" class="headerlink" title="3.5.4 自连接和联合查询"></a>3.5.4 自连接和联合查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#自连接</span><br><span class="line">#自连接：当前表与自身的连接查询，可以是内连接，也可以是外连接, 自连接必须使用表别名(要给表起别名，n次)</span><br><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</span><br><span class="line">#自连接查询：</span><br><span class="line">#查询员工 及其 所属领导的名字	</span><br><span class="line">#表结构: emp</span><br><span class="line">select a.name , b.name from emp a , emp b where a.managerid = b.id</span><br><span class="line">#查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来	</span><br><span class="line">#表结构: emp a , emp b</span><br><span class="line">select a.name &#x27;员工&#x27;, b.name &#x27;领导&#x27; from emp a left join emp b on a.managerid =b.id;</span><br><span class="line">//在自连接查询中，必须要为表起别名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#联合查询</span><br><span class="line">//对于联合查询的多张表列数必须保持一致，字段类型也需要保持一致。 </span><br><span class="line">//把两张表查询的结果拼接，会有重复，union all直接合并全部数据，union会去重。</span><br><span class="line">#将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来</span><br><span class="line">select * from emp where salary &lt; 5000</span><br><span class="line">union all</span><br><span class="line">select * from emp where age &gt; 50;</span><br></pre></td></tr></table></figure>





<h3 id="3-5-5-子查询"><a href="#3-5-5-子查询" class="headerlink" title="3.5.5.子查询"></a>3.5.5.子查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#又叫嵌套查询</span><br><span class="line">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 )</span><br><span class="line"></span><br><span class="line">#分类</span><br><span class="line">#根据子查询结果不同，分为：</span><br><span class="line">A. 标量子查询：子查询结果（那个先查出来的语句）为单个值 </span><br><span class="line">B. 列子查询：子查询结果为一列  in ，not in, any ,some ,all </span><br><span class="line">C. 行子查询：子查询结果为一行</span><br><span class="line">D. 表子查询：子查询结果为多行多列。</span><br><span class="line"></span><br><span class="line">#标量子查询</span><br><span class="line">//常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;= </span><br><span class="line">#查询 &quot;销售部&quot; 的所有员工信息 </span><br><span class="line">select * from emp where dept_id = (select id from dept where name = &#x27;销售部&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#列子查询</span><br><span class="line">//常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</span><br><span class="line">#查询 &quot;销售部&quot; 和 &quot;市场部&quot; 的所有员工信息</span><br><span class="line">select * from emp where dept_id in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">#查询比 财务部 所有人工资都高的员工信息</span><br><span class="line"> select * from emp where salary &gt; all ( select salary from emp where dept_id =</span><br><span class="line">(select id from dept where name = &#x27;财务部&#x27;) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#行子查询</span><br><span class="line">//常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</span><br><span class="line">#查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息 ;</span><br><span class="line">select * from emp where (salary,managerid) = (select salary, managerid from emp</span><br><span class="line">where name = &#x27;张无忌&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#表子查询</span><br><span class="line">//常用的操作符：IN</span><br><span class="line">#查询与 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资相同的员工信息</span><br><span class="line">select * from emp where (job,salary) in ( select job, salary from emp where name =&#x27;鹿杖客&#x27; or name = &#x27;宋远桥&#x27; );</span><br><span class="line"># 查询各部门的平均工资：</span><br><span class="line">#（select 后紧跟的子查询，表子查询）</span><br><span class="line">select  distinct  e2.dept_id,  (select avg(salary) from emp  e1 where e1.dept_id =e2.dept_id ) &#x27;平均工资&#x27; from emp e2;</span><br></pre></td></tr></table></figure>







<h2 id="4-用户和权限"><a href="#4-用户和权限" class="headerlink" title="4 用户和权限"></a>4 用户和权限</h2><h3 id="4-1-管理用户"><a href="#4-1-管理用户" class="headerlink" title="4.1 管理用户"></a>4.1 管理用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询用户</span><br><span class="line">select * from mysql.user;</span><br><span class="line"></span><br><span class="line">#创建用户</span><br><span class="line">REATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line">//在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</span><br><span class="line">//主机名可以使用 % 通配</span><br><span class="line"></span><br><span class="line">#修改用户密码</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27; ;</span><br><span class="line"></span><br><span class="line">#删除用户</span><br><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27; </span><br></pre></td></tr></table></figure>



<h3 id="4-2-权限控制"><a href="#4-2-权限控制" class="headerlink" title="4.2 权限控制"></a>4.2 权限控制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询权限</span><br><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; ;</span><br><span class="line"></span><br><span class="line">#授予权限</span><br><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">//多个权限之间，使用逗号分隔</span><br><span class="line">//授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</span><br><span class="line"></span><br><span class="line">#撤销权限</span><br><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>





<h2 id="5-约束"><a href="#5-约束" class="headerlink" title="5.约束"></a>5.约束</h2><table>
<thead>
<tr>
<th>唯一约束</th>
<th>保证该字段的所有数据都是唯一、不重复的</th>
<th>UNIQUE</th>
</tr>
</thead>
<tbody><tr>
<td>检查约束(8.0.16版本 之后)</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#外键约束</span><br><span class="line"></span><br><span class="line">#添加外键</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)</span><br><span class="line">REFERENCES 主表 (主表列名) ;</span><br><span class="line">#案例：为emp表的dept_id字段添加外键约束,关联dept表的主键id。</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references</span><br><span class="line">dept(id);</span><br><span class="line"></span><br><span class="line">#删除外键</span><br><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称</span><br><span class="line">#案例：删除emp表的外键fk_emp_dept_id。</span><br><span class="line">alter table emp drop foreign key fk_emp_dept_id;</span><br></pre></td></tr></table></figure>





<h2 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务不可分割，事务四大特性：</span><br><span class="line">原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span><br><span class="line">一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</span><br><span class="line">隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立</span><br><span class="line">环境下运行。</span><br><span class="line">持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看/设置事务提交方式</span><br><span class="line">select @@autocommit;</span><br><span class="line">set @@autocommit=0;</span><br><span class="line"></span><br><span class="line">#开启事务 </span><br><span class="line">start transaction ; </span><br><span class="line">//beigin;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line">rollback</span><br></pre></td></tr></table></figure>





<h3 id="6-1-并发事务问题和解决"><a href="#6-1-并发事务问题和解决" class="headerlink" title="6.1 并发事务问题和解决"></a>6.1 并发事务问题和解决</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#并发事务问题</span><br><span class="line">1）脏读：一个事务读到另一个事务还没有提交的数据。</span><br><span class="line">2）不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</span><br><span class="line">3）幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#解决</span><br><span class="line">#事务隔离级别是用来解决事务并发问题的。</span><br><span class="line">| 隔离级别                     | 脏读 | 不可重复读 | 幻读 |</span><br><span class="line">| ---------------------------- | ---- | ---------- | ---- |</span><br><span class="line">| read uncommitted             | √    | √          | √    |</span><br><span class="line">| read committed（oracle默认） | ×    | √          | √    |</span><br><span class="line">| repeatable read （mysql默认) | ×    | ×          | √    |</span><br><span class="line">| serializable                 | ×    | ×          | ×    |</span><br><span class="line"></span><br><span class="line">#查看事务隔离级别</span><br><span class="line">select @@transaction_isolation;</span><br><span class="line"># 设置事务隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted ;</span><br><span class="line">set session transaction isolation level repeatable read ;</span><br><span class="line">//注意：事务的隔离级别越高，数据越安全，但是性能越低。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="7-Mysql存储引擎"><a href="#7-Mysql存储引擎" class="headerlink" title="7.Mysql存储引擎"></a>7.Mysql存储引擎</h2><h3 id="7-1-体系结构"><a href="#7-1-体系结构" class="headerlink" title="7.1 体系结构"></a>7.1 体系结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#连接层</span><br><span class="line">主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程</span><br><span class="line">池的概念，为通过认证安全接入的客户端提供线程</span><br><span class="line"></span><br><span class="line">#服务层</span><br><span class="line">SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等</span><br><span class="line"></span><br><span class="line">#引擎层  索引所在层</span><br><span class="line">负责了MySQL中数据的存储和提取</span><br><span class="line"></span><br><span class="line">#存储层</span><br><span class="line">主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询</span><br><span class="line">日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互</span><br></pre></td></tr></table></figure>



<h3 id="7-2-存储引擎："><a href="#7-2-存储引擎：" class="headerlink" title="7.2 存储引擎："></a>7.2 存储引擎：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。</span><br><span class="line">#建表时指定存储引擎</span><br><span class="line">create table xxx () engine=MyISM;</span><br><span class="line">#查询当前数据库支持的存储引擎</span><br><span class="line">show engines</span><br><span class="line"></span><br><span class="line">#InnoDB：MySql 5.5之后的   高可靠性和高性能。</span><br><span class="line">//DML,ACID，支持事务</span><br><span class="line">//行级锁</span><br><span class="line">//支持外键</span><br><span class="line"></span><br><span class="line">#xxx.ibd 表空间文件。表结构（frm,sdi)，数据和索引</span><br><span class="line">参数：innodb_file_per_table</span><br></pre></td></tr></table></figure>





<h2 id="8-索引"><a href="#8-索引" class="headerlink" title="8. 索引"></a>8. 索引</h2><p>定义：高效获取数据的数据结构（有序）。其中：无索引，全表扫描。有索引，走二叉树扫描。</p>
<h3 id="8-1-B-Tree索引"><a href="#8-1-B-Tree索引" class="headerlink" title="8.1 B+Tree索引"></a>8.1 B+Tree索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//B树</span><br><span class="line">B树是一种多叉路衡查找树.</span><br><span class="line">每个结点的值严格小于度数。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针.</span><br><span class="line"></span><br><span class="line">//B+树</span><br><span class="line">B+Tree 与 B-Tree相比，主要有以下三点区别： </span><br><span class="line">所有的数据都会出现在叶子节点。 </span><br><span class="line">叶子节点形成一个单向链表。 </span><br><span class="line">非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</span><br><span class="line">//Mysql中的B+数的叶子节点形成的是双向链表。数据存叶子节点。</span><br><span class="line"></span><br><span class="line">//为啥InnoDB存储引擎采用B+树</span><br><span class="line">A.相对于二叉树，层级更少，搜索效率高</span><br><span class="line">B.对于B树，无论是叶子节点还是非叶子节点，都会保存数据，这样导致页表（页表就是CPU中的缓存页表，有个置换算法）中存储的键值减少，指针也少，要保存大量数据，只能增加树的高度，IO次数（磁盘读写）多，导致性能降低。</span><br><span class="line">C. 相对Hash索引，B+tree支持范围匹配及排序操作；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//InnoDB主键索引的B+Tree高度为多高？</span><br><span class="line">一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。</span><br><span class="line">高度为2：</span><br><span class="line">n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</span><br><span class="line">1171* 16 = 18736</span><br><span class="line">也就是说，如果树的高度为2，则可以存储 18000 多条记录。</span><br><span class="line">高度为3：</span><br><span class="line">1171 * 1171 * 16 = 21939856</span><br><span class="line">也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</span><br></pre></td></tr></table></figure>



<h3 id="8-2-哈希索引"><a href="#8-2-哈希索引" class="headerlink" title="8.2 哈希索引"></a>8.2 哈希索引</h3><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p>
<p>结构：采用一定的哈希算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。hash冲突，采用链表解决。</p>
<h3 id="8-3-索引分类"><a href="#8-3-索引分类" class="headerlink" title="8.3 索引分类"></a>8.3 索引分类</h3><table>
<thead>
<tr>
<th>主键索引</th>
<th>针对于表中主键创建的索引</th>
<th>默认自动创建</th>
</tr>
</thead>
<tbody><tr>
<td>唯一索引</td>
<td>避免同一个表中的某数据列中的值重复</td>
<td>可以有多个</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词。而不是比较索引中的值</td>
<td>可以有多个</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>将数据与索引放到了一块，索引结构的叶子节点保存了行数据</th>
<th>必须有，而且有多个</th>
</tr>
</thead>
<tbody><tr>
<td>二级索引</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//聚集索引选取规则：</span><br><span class="line">如果存在主键，主键索引就是聚集索引。</span><br><span class="line">如果不存在主键，将使用第一个唯一索引作为聚集索引</span><br><span class="line">如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成kowid作为隐藏的聚集索引。</span><br><span class="line"></span><br><span class="line">//聚集索引和二级索引的区别：</span><br><span class="line">聚集索引的叶子节点下挂的是这一行的数据</span><br><span class="line">二级索引的叶子节点下挂的是该字段值对应的主键值（聚集索引的主键值，然后再回表查询）。</span><br></pre></td></tr></table></figure>



<h3 id="8-4-覆盖索引"><a href="#8-4-覆盖索引" class="headerlink" title="8.4 覆盖索引"></a>8.4 覆盖索引</h3><p>尽量使用覆盖索引，减少select * </p>
<p>覆盖索引指的是查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。（就是select紧跟着的那些字段，在where之后的字段或者是在索引那（这时候走二级索引和聚集索引）那可以找到，这种就是覆盖索引）</p>
<table>
<thead>
<tr>
<th>using index condition</th>
<th>查找使用了索引，但是需要回表查询数据</th>
</tr>
</thead>
<tbody><tr>
<td>using where ;using index:</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对</span><br><span class="line">以下SQL语句进行优化, 该如何进行才是最优方案:</span><br><span class="line">select id,username,password from tb_user where username =&#x27;itcast&#x27;;</span><br><span class="line"></span><br><span class="line">答案: 针对于 username, password建立联合索引, sql为: create index</span><br><span class="line">idx_user_name_pass on tb_user(username,password);</span><br><span class="line">这样可以避免上述的SQL语句，在查询的过程中，出现回表查询</span><br></pre></td></tr></table></figure>



<h3 id="8-5-前缀索引"><a href="#8-5-前缀索引" class="headerlink" title="8.5 前缀索引"></a>8.5 前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext等）时，，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_xxxx on table_name(column(n)) ;</span><br><span class="line">#为tb_user表的email字段，建立长度为5的前缀索引</span><br><span class="line">create index ide_email_5 on tb_user(email(5))</span><br></pre></td></tr></table></figure>



<h3 id="8-6-单列索引与联合索引"><a href="#8-6-单列索引与联合索引" class="headerlink" title="8.6 单列索引与联合索引"></a>8.6 单列索引与联合索引</h3><p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<h3 id="8-7-索引使用"><a href="#8-7-索引使用" class="headerlink" title="8.7 索引使用"></a>8.7 索引使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">基本使用</span><br><span class="line"></span><br><span class="line">#创建索引</span><br><span class="line">create [unique|fulltext] index index_name on table_name (index_col_name,...);</span><br><span class="line"></span><br><span class="line">#查看索引</span><br><span class="line">show  index from table_name;</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line">drop index index_name on table_name;</span><br><span class="line"></span><br><span class="line">#案例：为profession、age、status创建联合索引。</span><br><span class="line">create index idx_pro_age_sta on table_user(professional,age,status);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">验证索引效率</span><br><span class="line"></span><br><span class="line">//在未建立索引之前，执行如下SQL语句，查看耗时</span><br><span class="line">select * from tb_sku where sn=&quot;xxxx&quot;;</span><br><span class="line"></span><br><span class="line">#再创建索引</span><br><span class="line">create index idx_sku_sn on tb_sku(sn);</span><br><span class="line"></span><br><span class="line">#再执行语句查看耗时</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">索引提示</span><br><span class="line"></span><br><span class="line">//那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于 MySQL的SQL提示来完成。 接下来，介绍一下SQL提示。</span><br><span class="line">//use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</span><br><span class="line">explain select * from tb_user use index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">//ignore index ： 忽略指定的索引。</span><br><span class="line">explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">//force index ： 强制使用索引。</span><br><span class="line">explain select * from tb_user force index(idx_user_pro) where profession = &#x27;软件工</span><br><span class="line">程&#x27;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>





<h3 id="8-8-索引失效情况"><a href="#8-8-索引失效情况" class="headerlink" title="8.8 索引失效情况"></a>8.8 索引失效情况</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.不遵守最左前缀法则</span><br><span class="line">最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</span><br><span class="line">联合索引 profession ,age,status ，要求profession必须存在。</span><br><span class="line">abc 中如果是ac这种是索引部分失效（还是走索引的，只有bc这种情况不走索引）</span><br><span class="line">注意：</span><br><span class="line"> 如果跳过之前的，那么走全表扫描。</span><br><span class="line"> 如果联合索引的字段都有也是走索引的，会进行优化。索引长度正常。</span><br><span class="line"></span><br><span class="line"># 2.范围查询</span><br><span class="line">联合索引中，出现范围查询(&lt;,&gt;) 范围查询右侧的列索引失效。如果包含等于，则不会。</span><br><span class="line"></span><br><span class="line">#3. 进行运算</span><br><span class="line">不要在索引上进行运算操作，例如加substring索引将失效。</span><br><span class="line"></span><br><span class="line">#4.字符串不加引号</span><br><span class="line">字符串类型字段使用时，不加引号，索引将失效。</span><br><span class="line"></span><br><span class="line">#5.头部模糊查询</span><br><span class="line">如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效。</span><br><span class="line"></span><br><span class="line">#6. or连接的条件（只有两侧都有才可以）</span><br><span class="line">用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</span><br></pre></td></tr></table></figure>





<h3 id="8-9-索引设计原则"><a href="#8-9-索引设计原则" class="headerlink" title="8.9 索引设计原则"></a>8.9 索引设计原则</h3><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立联合索引，而非单列索引。//如果多个字段，只会走一个索引，其余的会回表查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1). 针对于数据量较大，且查询比较频繁的表建立索引。</span><br><span class="line">2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</span><br><span class="line">3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</span><br><span class="line">4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</span><br><span class="line">5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，</span><br><span class="line">避免回表，提高查询效率。</span><br><span class="line">6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</span><br><span class="line">7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</span><br></pre></td></tr></table></figure>



<h1 id="9-SQL性能分析"><a href="#9-SQL性能分析" class="headerlink" title="9 SQL性能分析"></a>9 SQL性能分析</h1><h2 id="9-1-SQL执行频率"><a href="#9-1-SQL执行频率" class="headerlink" title="9.1  SQL执行频率"></a>9.1  SQL执行频率</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global status like&#x27;Com________&#x27;;	</span><br><span class="line"></span><br><span class="line">//7个下划线，第一个无含义，后面是匹配6个字符比如select，delete</span><br><span class="line">//Com_insert: 插入次数</span><br><span class="line">//Com_select: 查询次数</span><br><span class="line">//Com_update: 更新次数</span><br></pre></td></tr></table></figure>



<h2 id="9-2-慢查询日志"><a href="#9-2-慢查询日志" class="headerlink" title="9.2 慢查询日志"></a>9.2 慢查询日志</h2><p>记录了所有执行时间超过指定参数（long_query_time默认10秒）的所有SQL语句的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Mysql的慢查询日志默认没有开启，</span><br><span class="line">show variables like &#x27;slow_query_log&#x27;</span><br><span class="line"></span><br><span class="line">#如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</span><br><span class="line">#开启MySql慢查询日志查询开关</span><br><span class="line">show_query_log=1</span><br><span class="line">#设置慢日志的时间为2秒，SQL语句执行语句超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br><span class="line">//windows下修改：C:\ProgramData\MySQL\MySQL Server 8.0的my.ini</span><br><span class="line"></span><br><span class="line">//配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log</span><br><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">执行如下SQL语句 ：</span><br><span class="line">select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00sec select count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时 13.35sec</span><br></pre></td></tr></table></figure>



<h2 id="9-3-profile详情"><a href="#9-3-profile详情" class="headerlink" title="9.3 profile详情"></a>9.3 profile详情</h2><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗到哪里去了，通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@have_profiling;	//0表示没有开启开关。</span><br><span class="line">#默认profiling是关闭的，可以通过set语句在session/global级别开启profiling</span><br><span class="line">set profiling=1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">select * from tb_user;</span><br><span class="line">select * from tb_user where id = 1;</span><br><span class="line">select * from tb_user where name = &#x27;白起&#x27;;</span><br><span class="line">select count(*) from tb_sku;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//然后通过如下指令查看指令的执行耗时：</span><br><span class="line">#查看每一条SQL的耗时基本情况</span><br><span class="line">show profiles;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="line">show profile for query query_id</span><br><span class="line"></span><br><span class="line">#查看指定query_id的SQL语句CPU的使用情况</span><br><span class="line">show profile cpu for query query_id</span><br></pre></td></tr></table></figure>



<h2 id="9-4-explain"><a href="#9-4-explain" class="headerlink" title="9.4 explain"></a>9.4 explain</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//explain或者desc命令获取mysql如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序</span><br><span class="line">//直接在语句前加一个explain</span><br><span class="line">EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</span><br></pre></td></tr></table></figure>

<p>各字段含义：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select 查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下;id不同，值越大，越先执行）。</th>
</tr>
</thead>
<tbody><tr>
<td>select_type</td>
<td>表示select的类型，常见的取值有simple（简单表，即不适用表连接或者子查询），primary（主查询，即外层的查询），union（union中的第二个或者后面的查询语句），subquery（select/where之后包含了子查询)等。</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为NULL,system,const,eq_ref,range,index,all。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</td>
</tr>
<tr>
<td>rows</td>
<td>Mysql认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比，filtered的值越大越好.</td>
</tr>
</tbody></table>
<p>extra为null表示回表查询，为use index则使用了索引。</p>
<h1 id="10-SQL优化"><a href="#10-SQL优化" class="headerlink" title="10. SQL优化"></a>10. SQL优化</h1><h2 id="10-1-普通insert"><a href="#10-1-普通insert" class="headerlink" title="10.1 普通insert"></a>10.1 普通insert</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#批量插入</span><br><span class="line">Insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);</span><br><span class="line"></span><br><span class="line">#手动提交事务</span><br><span class="line">start transaction;</span><br><span class="line">insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);</span><br><span class="line">insert into tb_test values(4,&#x27;Tom&#x27;),(5,&#x27;Cat&#x27;),(6,&#x27;Jerry&#x27;);</span><br><span class="line">insert into tb_test values(7,&#x27;Tom&#x27;),(8,&#x27;Cat&#x27;),(9,&#x27;Jerry&#x27;);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">//主键顺序插入，性能要高于乱序插入</span><br><span class="line">主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3</span><br><span class="line">主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</span><br></pre></td></tr></table></figure>



<h2 id="10-2-大批量插入"><a href="#10-2-大批量插入" class="headerlink" title="10.2 大批量插入"></a>10.2 大批量插入</h2><p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用Mysql数据库提供的load指令进行插入。操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//客户端连接服务端时，加上参数 </span><br><span class="line">local-infile mysql –-local-infile -u root -p</span><br><span class="line">//在load时，主键顺序插入性能高于乱序插入</span><br><span class="line"></span><br><span class="line">//设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line"></span><br><span class="line">//执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ;</span><br></pre></td></tr></table></figure>





<h2 id="10-3-主键设计原则"><a href="#10-3-主键设计原则" class="headerlink" title="10.3 主键设计原则"></a>10.3 主键设计原则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">满足业务需求的情况下，尽量降低主键的长度。</span><br><span class="line">插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</span><br><span class="line">尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</span><br><span class="line">业务操作时，避免对主键的修改。</span><br></pre></td></tr></table></figure>



<h2 id="10-4-其他优化"><a href="#10-4-其他优化" class="headerlink" title="10.4 其他优化"></a>10.4 其他优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">order by优化</span><br><span class="line"></span><br><span class="line">//MySQL的排序，有两种方式：</span><br><span class="line">Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</span><br><span class="line">Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</span><br><span class="line"></span><br><span class="line">//order by默认不走索引。</span><br><span class="line">//创建索引：</span><br><span class="line">create index idx_user_age_phone_aa on tb_user(age,phone);</span><br><span class="line">//explain select id,age,phone from tb_user order by age; 走索引</span><br><span class="line">//explain select id,age,phone from tb_user order by age , phone; 走索引</span><br><span class="line"></span><br><span class="line">//explain select id,age,phone from tb_user order by age desc , phone desc ;走索引+反向扫描</span><br><span class="line"></span><br><span class="line">//一个降序一个升序情况：</span><br><span class="line">//explain select id,age,phone from tb_user order by age asc , phone desc ;  using filesort+using index</span><br><span class="line">//解决上述一个降序一个升序情况：</span><br><span class="line">create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);</span><br><span class="line">//explain select id,age,phone from tb_user order by age asc , phone desc ;  走索引</span><br><span class="line"></span><br><span class="line">//order by优化原则: </span><br><span class="line">A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。 （上述一个升序一个降序的有问题的那，age走了索引）</span><br><span class="line">B. 尽量使用覆盖索引。 </span><br><span class="line">C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。 </span><br><span class="line">D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//group by优化</span><br><span class="line">建立联合索引。这里group by 要满足最左前缀匹配原则。</span><br><span class="line"></span><br><span class="line">//count优化</span><br><span class="line">按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽 量使用 count(*)。</span><br><span class="line"></span><br><span class="line">//limit优化</span><br><span class="line">#覆盖索引加子查 询形式进行优化。</span><br><span class="line">select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;</span><br><span class="line"></span><br><span class="line">//update优化</span><br><span class="line">//行锁</span><br><span class="line">update course set name = &#x27;javaEE&#x27; where id = 1 ;</span><br><span class="line">//行锁升级为表锁</span><br><span class="line">update course set name = &#x27;SpringBoot&#x27; where name = &#x27;PHP&#x27; </span><br><span class="line">//InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 </span><br></pre></td></tr></table></figure>





<h1 id="11-视图"><a href="#11-视图" class="headerlink" title="11.视图"></a>11.视图</h1><p>视图是虚拟表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建</span><br><span class="line">CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [</span><br><span class="line">CASCADED | LOCAL ] CHECK OPTION ]</span><br><span class="line">//create or replace view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">查看创建视图语句：SHOW CREATE VIEW 视图名称;</span><br><span class="line">查看视图数据：SELECT * FROM 视图名称 ...... ;</span><br><span class="line">//show create view stu_v_1;</span><br><span class="line">//select * from stu_v_1;</span><br><span class="line">//select * from stu_v_1 where id &lt; 3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</span><br><span class="line">//create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;</span><br><span class="line"></span><br><span class="line">方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</span><br><span class="line">//alter view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...</span><br><span class="line">//drop view if exists stu_v_1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//视图是可以用来插入数据的</span><br><span class="line">create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;</span><br><span class="line">select * from stu_v_1;</span><br><span class="line">insert into stu_v_1 values(6,&#x27;Tom&#x27;);</span><br><span class="line">insert into stu_v_1 values(17,&#x27;Tom22&#x27;);</span><br><span class="line">//id为6和17的数据都是可以成功插入的。 但是我们执行查询，查询出</span><br><span class="line">来的数据，却没有id为17的记录。</span><br><span class="line">//可以根据视图的检查选项来进行插入，修改删除数据。</span><br></pre></td></tr></table></figure>





<h2 id="11-1检查选项和更新"><a href="#11-1检查选项和更新" class="headerlink" title="11.1检查选项和更新"></a>11.1检查选项和更新</h2><p>mysql提供了两个选项，CASCADED 和 LOCAL ，默认值为 CASCADED 。</p>
<p>1）CASCADED 级联</p>
<p>2）LOCAL 本地</p>
<p>视图行于基础表的行一对一。如果包含以下任何一项，则不可更新:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） </span><br><span class="line">DISTINCT </span><br><span class="line">GROUP BY </span><br><span class="line">HAVING </span><br><span class="line">UNION 或者 UNION ALL</span><br></pre></td></tr></table></figure>



<h2 id="11-2-视图作用"><a href="#11-2-视图作用" class="headerlink" title="11.2 视图作用"></a>11.2 视图作用</h2><p>简单 ，安全，数据独立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例：</span><br><span class="line">#为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽 手机号和邮箱两个字段</span><br><span class="line">create view tb_user_view as select id,name,profession,age,gender,status,createtime</span><br><span class="line">from tb_user;</span><br><span class="line">select * from tb_user_view;</span><br><span class="line"></span><br><span class="line">#查询每个学生所选修的课程（三张表联查），为了简化操作，定义一个视图</span><br><span class="line">create view tb_stu_course_view as select s.name student_name , s.no student_no ,</span><br><span class="line">c.name course_name from student s, student_course sc , course c where s.id =</span><br><span class="line">sc.studentid and sc.courseid = c.id;</span><br><span class="line"></span><br><span class="line">select * from tb_stu_course_view;</span><br></pre></td></tr></table></figure>





<h1 id="12-MySQL中的锁"><a href="#12-MySQL中的锁" class="headerlink" title="12.MySQL中的锁"></a>12.MySQL中的锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局锁：锁定数据库中的所有表。 </span><br><span class="line">表级锁：每次操作锁住整张表。 </span><br><span class="line">行级锁：每次操作锁住对应的行数据。</span><br></pre></td></tr></table></figure>



<h2 id="12-1全局锁"><a href="#12-1全局锁" class="headerlink" title="12.1全局锁"></a>12.1全局锁</h2><p>对整个数据库实例加锁，加锁后整个实例处于只读状态，后续事务提交语句会被阻塞。</p>
<p>典型使用场景：数据库的逻辑备份。对所有表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#加全局锁</span><br><span class="line">flush table with read lock;</span><br><span class="line"></span><br><span class="line">#数据备份</span><br><span class="line">mysqldump -uroot -p1234 itcast &gt;itcast.sql</span><br><span class="line"></span><br><span class="line">#释放锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">//在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致 性数据备份</span><br><span class="line">mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure>





<h2 id="12-2-表级锁"><a href="#12-2-表级锁" class="headerlink" title="12.2 表级锁"></a>12.2 表级锁</h2><p>每次锁住操作整张表，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p>对于表级锁，主要分为以下三类： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表锁 </span><br><span class="line">元数据锁（meta data lock，MDL）</span><br><span class="line">意向锁</span><br></pre></td></tr></table></figure>



<h3 id="12-2-1-表锁"><a href="#12-2-1-表锁" class="headerlink" title="12.2.1 表锁"></a>12.2.1 表锁</h3><p>表锁，分为两类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表共享读锁（read lock） </span><br><span class="line">表独占写锁（write lock）</span><br><span class="line"></span><br><span class="line">//加锁：lock tables 表名... read/write</span><br><span class="line">// 释放锁：unlock tables / 客户端断开连接 </span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">读锁：lock tables score read; </span><br><span class="line">客户端一加读锁，不影响客户端二的读，但是会阻塞右侧客户端的写(update 这种会失败)</span><br><span class="line"></span><br><span class="line">写锁：lock tables score write;</span><br><span class="line">客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</span><br><span class="line"></span><br><span class="line">结论：读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</span><br></pre></td></tr></table></figure>



<h3 id="12-2-2-元数据锁"><a href="#12-2-2-元数据锁" class="headerlink" title="12.2.2 元数据锁"></a>12.2.2 元数据锁</h3><p>meta data lock ,简写MDL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MDL加锁过程是系统自动控制，无需显示使用。在访问一张表的时候会自动加上。表上有活动事务时，不可以对元数据（表结构）进行写入操作。</span><br><span class="line">MYSQL5.5中引入MDL,对表进行增删改查，加MDL读锁（共享），当对表结构变更，加MDL写锁（排他）</span><br></pre></td></tr></table></figure>

<p>常见的SQL操作时，所添加的元数据锁：</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read / write</td>
<td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、 delete、select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//演示说明：</span><br><span class="line">//当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是兼容的。</span><br><span class="line">#客户端一执行select * from score;此时加元数据共享锁，客户端二select * from score 加元数据共享锁，客户端二update score set math=88 where id=1 加元数据共享锁</span><br><span class="line"></span><br><span class="line">//当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁 （EXCLUSIVE），之间是互斥的</span><br><span class="line">客户端一执行select * from score,加元数据共享锁，</span><br><span class="line">客户端二alter table score add column java int; 此时是元数据排他锁，这个时候需要等元数据共享锁释放，耗时1min3sec</span><br><span class="line"></span><br><span class="line">//查看元数据锁的情况：</span><br><span class="line">select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;</span><br></pre></td></tr></table></figure>





<h3 id="12-2-3-意向锁"><a href="#12-2-3-意向锁" class="headerlink" title="12.2.3 意向锁"></a>12.2.3 意向锁</h3><p>为了避免DML在执行时，加的行锁和表锁冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分析</span><br><span class="line">首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁，</span><br><span class="line">当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低</span><br><span class="line">有了意向锁之后，</span><br><span class="line">客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</span><br><span class="line">而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了</span><br><span class="line"></span><br><span class="line">//分类</span><br><span class="line">意向共享锁(IS): </span><br><span class="line">由语句select ... lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥</span><br><span class="line">客户端一：select * from score where id=1 lock in share mode;加意向共享锁，此时客户端二加表的读锁lock tables score read;成功说明兼容</span><br><span class="line"></span><br><span class="line">//意向排他锁(IX): </span><br><span class="line">由insert、update、delete、select...for update添加 。与表锁共享 锁(read)及排他锁(write)都互斥，**意向锁之间不会互斥</span><br><span class="line">客户端一update score set math=66 where id=1;加意向排他锁，此时客户端二查询，lock tbales score read加表的读锁及写锁会阻塞</span><br><span class="line"></span><br><span class="line">//一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</span><br><span class="line">#可以通过以下SQL，查看意向锁及行锁的加锁情况：</span><br><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from</span><br><span class="line">performance_schema.data_locks;</span><br></pre></td></tr></table></figure>





<h2 id="12-3-行级锁"><a href="#12-3-行级锁" class="headerlink" title="12.3 行级锁"></a>12.3 行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p>
<p>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p>
<p>行级锁主要分为以下三类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行锁（Record Lock）：**锁定单个行记录的锁**，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持</span><br><span class="line">间隙锁（Gap Lock）：**锁定索引记录间隙（不含该记录）**，确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</span><br><span class="line">临键锁（Next-Key Lock）：**行锁和间隙锁组合**，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</span><br></pre></td></tr></table></figure>



<h3 id="12-3-1-行锁"><a href="#12-3-1-行锁" class="headerlink" title="12.3.1 行锁"></a>12.3.1 行锁</h3><p>InnoDB实现了以下两种类型的行锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共享锁（S）：</span><br><span class="line">允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</span><br><span class="line"> </span><br><span class="line">排他锁（X）：</span><br><span class="line">允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。（就是说锁定一行不让别的事务来动这一行，和其他的都互斥）</span><br></pre></td></tr></table></figure>

<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td>不加任何 锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在SELECT之后加LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在SELECT之后加FOR UPDATE</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//演示说明：</span><br><span class="line">//默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读</span><br><span class="line"></span><br><span class="line">#可以通过以下SQL查看意向锁及行锁的加锁情况：</span><br><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from</span><br><span class="line">performance_schema.data_locks;</span><br><span class="line"></span><br><span class="line">//解释：</span><br><span class="line">	普通的select语句，执行时，不会加锁。</span><br><span class="line">	select ...in share mode ，加共享锁，共享锁和共享锁之间兼容,	共享锁和排他锁之间互斥。(即客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行 数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互 斥。)</span><br><span class="line">	排他锁和排他锁互斥（当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更 新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互 斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。）</span><br><span class="line">	无索引行锁升级为表锁（在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。 然后在客户端二中更新id为3的记录，却不能直接执行，因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引， 此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。针对name字段建立索引，索引建立之后，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3 的数据时，更新成功，并未进入阻塞状态。 这样就说明，我们根据索引字段进行更新操作，就可以避 免行锁升级为表锁的情况。</span><br><span class="line">	</span><br><span class="line">//总结</span><br><span class="line">针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</span><br><span class="line">InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁。</span><br></pre></td></tr></table></figure>



<h3 id="12-3-2-间隙锁-amp-临键锁"><a href="#12-3-2-间隙锁-amp-临键锁" class="headerlink" title="12.3.2 间隙锁&amp;临键锁"></a>12.3.2 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁  </span><br><span class="line">#间隙锁不能插入中间的数据。</span><br><span class="line">id记录为1，3，8，查id=5的记录，优化为间隙锁，把8之前的数据都锁住，此时不能插入7</span><br><span class="line"></span><br><span class="line">//索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</span><br><span class="line">临建锁是等值查询age=3时，当遇到非唯一普通索引（age=3不止一个）时，如果最后一个值age=7不等于这个值age=3，则这个非等值age=7就是间隙锁，要查询的那个等值age=3就是临建锁(锁住3和3之前的间隙）。</span><br><span class="line"></span><br><span class="line">//索引上的范围查询(唯一索引)  会访问到不满足条件的第一个值为止。</span><br><span class="line">查&gt;=19,</span><br><span class="line">数据这时候分为</span><br><span class="line">[19]</span><br><span class="line">(19,25]</span><br><span class="line">(25,+∞]</span><br><span class="line">遇到11时继续走，遇到19加行锁，25的是临建锁（包含25和25之前的间隙），正无穷的临建锁（正无穷及之前的间隙）</span><br><span class="line"></span><br><span class="line">//注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。</span><br></pre></td></tr></table></figure>



<h1 id="13-日志"><a href="#13-日志" class="headerlink" title="13.日志"></a>13.日志</h1><h2 id="13-1错误日志："><a href="#13-1错误日志：" class="headerlink" title="13.1错误日志："></a>13.1错误日志：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//默认存放目录 /var/log/，默认的日志文件名为 mysqld.log</span><br><span class="line">#查看日志 位置：</span><br><span class="line">show variables like &#x27;%log_error%&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="13-2-二进制日志"><a href="#13-2-二进制日志" class="headerlink" title="13.2 二进制日志"></a>13.2 二进制日志</h2><p>记录了所有的DDL和DML，但是不包括查询语句。</p>
<p>作用：1.灾难时的数据恢复      2。MySQL的主从复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在MySQL8版本中，默认二进制日志是开启着 的，涉及到的参数如下：</span><br><span class="line">show variables like &#x27;%log_bin%&#x27;</span><br><span class="line"></span><br><span class="line">//参数说明：</span><br><span class="line">log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文 件名需要再该basename的基础上加上编号(编号从000001开始)。</span><br><span class="line">log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些</span><br></pre></td></tr></table></figure>



<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</p>
<table>
<thead>
<tr>
<th>日志格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>STATEMENT</td>
<td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在 日志文件中。</td>
</tr>
<tr>
<td>ROW</td>
<td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td>
</tr>
<tr>
<td>MIXED</td>
<td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会 自动切换为ROW进行记录。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%binlog_format%&#x27;</span><br><span class="line">//如果我们需要配置二进制日志的格式，只需要在 /etc/my.cnf 中配置 binlog_format 参数即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//查看</span><br><span class="line">//需要通过二进制日志查询工具mysqlbinlog来查看，具体语法：</span><br><span class="line">mysqlbinlog [ 参数选项 ] logfilename</span><br><span class="line">参数选项：</span><br><span class="line">-d 指定数据库名称，只列出指定的数据库相关操作。</span><br><span class="line">-o 忽略掉日志中的前n行命令。</span><br><span class="line">-v 将行事件(数据变更)重构为SQL语句</span><br><span class="line">-vv 将行事件(数据变更)重构为SQL语句，并输出注释信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">| 指令                                             | 含义                                                         |</span><br><span class="line">| ------------------------------------------------ | ------------------------------------------------------------ |</span><br><span class="line">| reset master                                     | 删除全部 binlog 日志，删除之后，日志编号，将 从 binlog.000001重新开始 |</span><br><span class="line">| purge master logs to &#x27;binlog.*&#x27;                  | 删除 * 编号之前的所有日志                                    |</span><br><span class="line">| purge master logs before &#x27;yyyy-mm-dd hh24:mi:ss&#x27; | 删除日志为 &quot;yyyy-mm-dd hh24:mi:ss&quot; 之前 产生的所有日志       |</span><br><span class="line"></span><br><span class="line">//也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</span><br><span class="line">show variables like &#x27;%binlog_expire_logs_seconds%&#x27;</span><br></pre></td></tr></table></figure>



<h2 id="13-3-查询日志"><a href="#13-3-查询日志" class="headerlink" title="13.3 查询日志"></a>13.3 查询日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//二进制日志不包含查询数据的SQL语句。默认情况下， 查询日志是未开启的。</span><br><span class="line">//可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：</span><br><span class="line"></span><br><span class="line">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启</span><br><span class="line">general_log=1</span><br><span class="line">#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log</span><br><span class="line">general_log_file=mysql_query.log</span><br><span class="line"></span><br><span class="line">//开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运 行后，该日志文件将会非常大。</span><br><span class="line"></span><br><span class="line">//慢查询日志</span><br><span class="line">//记录了所有执行时间超过参数long_query_time设置值并且扫描记录数不小于min_examined_row_limit的所有SQL语句的日志，默认未开启。需要开启则在在MySQL的配置文件 /etc/my.cnf 中配置如下参数：</span><br><span class="line">#慢查询日志</span><br><span class="line">slow_query_log=1</span><br><span class="line">#执行时间参数</span><br><span class="line">long_query_time=2</span><br><span class="line"></span><br><span class="line">//要记录管理语句以及不使用索引进行查找的查询，需要这样修改：</span><br><span class="line">#记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements =1</span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes = 1</span><br><span class="line">//注意：上述的所有参数配置完成后需要重启MySQL服务器才可以生效。</span><br></pre></td></tr></table></figure>





<h1 id="14-主从复制"><a href="#14-主从复制" class="headerlink" title="14.主从复制"></a>14.主从复制</h1><p>是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和猪数据库的数据保持一致。</p>
<h2 id="14-1-主从复制的原理"><a href="#14-1-主从复制的原理" class="headerlink" title="14.1 主从复制的原理"></a>14.1 主从复制的原理</h2><ul>
<li><p>MySql主库在事务提交时，会把数据变更作为事件记录在二进制日志Binlog中；</p>
</li>
<li><p>主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中（主库主动推送，如果是拉取主服务器压力太大），之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；</p>
</li>
<li><p>MySql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I/O线程和SQL线程跑着从库上；</p>
</li>
<li><p>当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，如下图所示。</p>
</li>
</ul>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_06.324e9265.png" alt="img"></p>
<h2 id="14-2-主库搭建"><a href="#14-2-主库搭建" class="headerlink" title="14.2 主库搭建"></a>14.2 主库搭建</h2><p>运行mysql主实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>在mysql的配置文件夹<code>/mydata/mysql-master/conf</code>中创建一个配置文件<code>my.cnf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch my.cnf</span><br></pre></td></tr></table></figure>

<p>修改配置文件my.cnf，配置信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=101 </span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mall-mysql-bin  </span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062  </span><br></pre></td></tr></table></figure>

<p>修改完配置后重启实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure>

<p>进入<code>mysql-master</code>容器中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-master /bin/bash</span><br></pre></td></tr></table></figure>

<p>在容器中使用mysql的登录命令连接到客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure>

<p>创建数据同步用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="14-3-从库搭建"><a href="#14-3-从库搭建" class="headerlink" title="14.3 从库搭建"></a>14.3 从库搭建</h2><p>运行mysql从实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>在mysql的配置文件夹<code>/mydata/mysql-slave/conf</code>中创建一个配置文件<code>my.cnf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch my.cnf</span><br></pre></td></tr></table></figure>

<p>修改配置文件my.cnf：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=102</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin=mall-mysql-slave1-bin  </span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=mall-mysql-relay-bin  </span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1  </span><br><span class="line">## slave设置为只读（具有super权限的用户除外）</span><br><span class="line">read_only=1  </span><br></pre></td></tr></table></figure>



<p>修改完配置后重启实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure>





<h2 id="14-4-将主从数据库进行连接"><a href="#14-4-将主从数据库进行连接" class="headerlink" title="14.4 将主从数据库进行连接"></a>14.4 将主从数据库进行连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#连接到主数据库的mysql客户端，查看主数据库状态：</span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p>主数据库状态显示如下：</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_01.b7042da2.png" alt="img"></p>
<p>进入<code>mysql-slave</code>容器中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-slave /bin/bash</span><br></pre></td></tr></table></figure>

<p>在容器中使用mysql的登录命令连接到客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure>

<p>在从数据库中配置主从复制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.6.132&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;  </span><br></pre></td></tr></table></figure>



<p>主从复制命令参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master_host：主数据库的IP地址；</span><br><span class="line">master_port：主数据库的运行端口；</span><br><span class="line">master_user：在主数据库创建的用于同步数据的用户账号；</span><br><span class="line">master_password：在主数据库创建的用于同步数据的用户密码；</span><br><span class="line">master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</span><br><span class="line">master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</span><br><span class="line">master_connect_retry：连接失败重试的时间间隔，单位为秒。</span><br></pre></td></tr></table></figure>



<p>查看主从同步状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>



<p>从数据库状态显示如下：</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_02.af0d3f94.png" alt="img"></p>
<p>开启主从同步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>查看从数据库状态发现已经同步：</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_03.f7bd494f.png" alt="img"></p>
<h2 id="14-5-主从复制测试"><a href="#14-5-主从复制测试" class="headerlink" title="14.5 主从复制测试"></a>14.5 主从复制测试</h2><p>在主实例中创建一个数据库mall</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_04.6405bafb.png" alt="img"></p>
<p>在从实例中查看数据库，发现也有一个<code>mall</code>数据库，可以判断主从复制已经搭建成功</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_05.98946658.png" alt="img"></p>
<h1 id="15-分库分表"><a href="#15-分库分表" class="headerlink" title="15 .分库分表"></a>15 .分库分表</h1><p>将数据分散存储。</p>
<p><strong>分库</strong>：就是一个数据库分成多个数据库，部署到不同机器。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AicsnEw0OkZjCPjCqpkGq6P3waq8eJCSc2vwbfUuxvWK64RMMZqxD50Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>分表</strong>：就是一个数据库表分成多个表，将一些<strong>不常用的、数据较大或者长度较长的列</strong>拆分到另外一张表</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AMxvOPgTA6ALzw9k5mb2ribiaTIz7rkHEhouHiaFSm4erVEia814zUMzKuA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="15-1-拆分策略："><a href="#15-1-拆分策略：" class="headerlink" title="15.1 拆分策略："></a>15.1 拆分策略：</h2><p>垂直拆封和水平拆分。拆分的粒度分为分库和分表。</p>
<h3 id="15-1-1-垂直拆分"><a href="#15-1-1-垂直拆分" class="headerlink" title="15.1.1 垂直拆分"></a>15.1.1 垂直拆分</h3><p>1.垂直分库</p>
<p>以表为依据，根据业务将不同表拆分到不同库中</p>
<p>特点：</p>
<p>每个库的表结构不一样</p>
<p>每个库的数据也不一样</p>
<p>所有库的并集是全量数据</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AVSic0IicIW2He4dRg59PM9XlhlbFTfXS3VHuYia95LQjy2SF4Ke1kiblJA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2.垂直分表</p>
<p>以字段为依据，根据字段属性将不同字段拆分到不同表中。</p>
<p>特点：</p>
<p>每个表的结果都不一样</p>
<p>每个表的数据也不一样，一般通过一列（主键/外键）关联</p>
<p>所有表的并集是全量数据</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8Aibxn3h0lyYFHVviaAmiaCvY9h0VKtwlZgvkpkPkibqD7dgzSibuzX2SWyicQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-1-4水平分库"><a href="#15-1-4水平分库" class="headerlink" title="15.1.4水平分库"></a>15.1.4水平分库</h3><p>将表的数据量切分到不同的数据库服务器上，每个服务器具有相同的库和表，只是表中的数据集合不一样。它可以有效的缓解单机单库的性能瓶颈和压力</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8A3e4RicicoH3aXicAFmia4yUHTV2BSNQ8lkh1JyhJnwfbNfHZgzu9QKTJeQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-1-5-水平分表"><a href="#15-1-5-水平分表" class="headerlink" title="15.1.5 水平分表"></a>15.1.5 水平分表</h3><p>如果一个表的数据量太大，可以按照某种规则（如<code>hash取模、range</code>），把数据切分到多张表去。</p>
<p>一张订单表，按<code>时间range</code>拆分如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AYYRhzKL5cfUxicYcz2tph0mDQVoPMC889aT72nLz2PyXB5PpBsronBg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">lsd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/18/MySQL%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">http://example.com/2022/11/18/MySQL%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">lsd</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/24/Nacos-SpringCloud/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nacos SpringCloud</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/16/Mybatis%E5%92%8CMybatisPlus%E7%9A%84%E4%BD%BF%E7%94%A8/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis和MybatisPlus的使用</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lsd</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-SQL%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">1. SQL语句分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">2. 数据库操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">3 表操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 添加数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 删除数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 修改数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-alter"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1  alter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-update"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2  update</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 单表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 基本查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3字符串类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. 多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 多表关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 内连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E8%87%AA%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 自连接和联合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.5.5.</span> <span class="toc-text">3.5.5.子查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90"><span class="toc-number">3.6.</span> <span class="toc-text">4 用户和权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="toc-number">3.6.1.</span> <span class="toc-text">4.1 管理用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">3.6.2.</span> <span class="toc-text">4.2 权限控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.7.</span> <span class="toc-text">5.约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.8.</span> <span class="toc-text">6.事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-number">3.8.1.</span> <span class="toc-text">6.1 并发事务问题和解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.9.</span> <span class="toc-text">7.Mysql存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.9.1.</span> <span class="toc-text">7.1 体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9A"><span class="toc-number">3.9.2.</span> <span class="toc-text">7.2 存储引擎：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%B4%A2%E5%BC%95"><span class="toc-number">3.10.</span> <span class="toc-text">8. 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-B-Tree%E7%B4%A2%E5%BC%95"><span class="toc-number">3.10.1.</span> <span class="toc-text">8.1 B+Tree索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">3.10.2.</span> <span class="toc-text">8.2 哈希索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">3.10.3.</span> <span class="toc-text">8.3 索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">3.10.4.</span> <span class="toc-text">8.4 覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">3.10.5.</span> <span class="toc-text">8.5 前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">3.10.6.</span> <span class="toc-text">8.6 单列索引与联合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.10.7.</span> <span class="toc-text">8.7 索引使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-number">3.10.8.</span> <span class="toc-text">8.8 索引失效情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">3.10.9.</span> <span class="toc-text">8.9 索引设计原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">9 SQL性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-SQL%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="toc-number">4.1.</span> <span class="toc-text">9.1  SQL执行频率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">4.2.</span> <span class="toc-text">9.2 慢查询日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-profile%E8%AF%A6%E6%83%85"><span class="toc-number">4.3.</span> <span class="toc-text">9.3 profile详情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-explain"><span class="toc-number">4.4.</span> <span class="toc-text">9.4 explain</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-SQL%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">10. SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%99%AE%E9%80%9Ainsert"><span class="toc-number">5.1.</span> <span class="toc-text">10.1 普通insert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%A4%A7%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-number">5.2.</span> <span class="toc-text">10.2 大批量插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.3.</span> <span class="toc-text">10.3 主键设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text">10.4 其他优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E8%A7%86%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">11.视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1%E6%A3%80%E6%9F%A5%E9%80%89%E9%A1%B9%E5%92%8C%E6%9B%B4%E6%96%B0"><span class="toc-number">6.1.</span> <span class="toc-text">11.1检查选项和更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E8%A7%86%E5%9B%BE%E4%BD%9C%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">11.2 视图作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-MySQL%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">12.MySQL中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">7.1.</span> <span class="toc-text">12.1全局锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">7.2.</span> <span class="toc-text">12.2 表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-1-%E8%A1%A8%E9%94%81"><span class="toc-number">7.2.1.</span> <span class="toc-text">12.2.1 表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2-%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">7.2.2.</span> <span class="toc-text">12.2.2 元数据锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-3-%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">7.2.3.</span> <span class="toc-text">12.2.3 意向锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">12.3 行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E8%A1%8C%E9%94%81"><span class="toc-number">7.3.1.</span> <span class="toc-text">12.3.1 行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E9%97%B4%E9%9A%99%E9%94%81-amp-%E4%B8%B4%E9%94%AE%E9%94%81"><span class="toc-number">7.3.2.</span> <span class="toc-text">12.3.2 间隙锁&amp;临键锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E6%97%A5%E5%BF%97"><span class="toc-number">8.</span> <span class="toc-text">13.日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">13.1错误日志：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">8.2.</span> <span class="toc-text">13.2 二进制日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.2.0.1.</span> <span class="toc-text">格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">8.3.</span> <span class="toc-text">13.3 查询日志</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">14.主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">14.1 主从复制的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E4%B8%BB%E5%BA%93%E6%90%AD%E5%BB%BA"><span class="toc-number">9.2.</span> <span class="toc-text">14.2 主库搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E4%BB%8E%E5%BA%93%E6%90%AD%E5%BB%BA"><span class="toc-number">9.3.</span> <span class="toc-text">14.3 从库搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E5%B0%86%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.4.</span> <span class="toc-text">14.4 将主从数据库进行连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">9.5.</span> <span class="toc-text">14.5 主从复制测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">10.</span> <span class="toc-text">15 .分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">15.1 拆分策略：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-1-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">10.1.1.</span> <span class="toc-text">15.1.1 垂直拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-4%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="toc-number">10.1.2.</span> <span class="toc-text">15.1.4水平分库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-5-%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8"><span class="toc-number">10.1.3.</span> <span class="toc-text">15.1.5 水平分表</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/24/SpringBoot-%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/" title="SpringBoot 注解大全"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot 注解大全"/></a><div class="content"><a class="title" href="/2022/11/24/SpringBoot-%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/" title="SpringBoot 注解大全">SpringBoot 注解大全</a><time datetime="2022-11-24T13:21:04.000Z" title="发表于 2022-11-24 21:21:04">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/24/Docker/" title="Docker"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2022/11/24/Docker/" title="Docker">Docker</a><time datetime="2022-11-24T13:15:08.000Z" title="发表于 2022-11-24 21:15:08">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/24/Nacos-SpringCloud/" title="Nacos SpringCloud"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nacos SpringCloud"/></a><div class="content"><a class="title" href="/2022/11/24/Nacos-SpringCloud/" title="Nacos SpringCloud">Nacos SpringCloud</a><time datetime="2022-11-24T12:51:04.000Z" title="发表于 2022-11-24 20:51:04">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/18/MySQL%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="MySQL的相关知识"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL的相关知识"/></a><div class="content"><a class="title" href="/2022/11/18/MySQL%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="MySQL的相关知识">MySQL的相关知识</a><time datetime="2022-11-18T12:51:36.000Z" title="发表于 2022-11-18 20:51:36">2022-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/Mybatis%E5%92%8CMybatisPlus%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Mybatis和MybatisPlus的使用"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis和MybatisPlus的使用"/></a><div class="content"><a class="title" href="/2022/11/16/Mybatis%E5%92%8CMybatisPlus%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Mybatis和MybatisPlus的使用">Mybatis和MybatisPlus的使用</a><time datetime="2022-11-16T14:11:39.000Z" title="发表于 2022-11-16 22:11:39">2022-11-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By lsd</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>