<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker</title>
    <url>/2022/11/24/Docker/</url>
    <content><![CDATA[<p>待完成</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker将用户程序和所需要调用系统的函数库一起打包。</p>
<p>镜像和容器：</p>
<p>​    镜像：Docker将应用程序及其所需的依赖，函数库，环境，配置等文件打包在一起，称为镜像。</p>
<p>​    容器：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器做隔离，对外不可见。</p>
<p>DockerHub是镜像托管平台。</p>
<p>Docker架构：</p>
<p>​    CS架构</p>
<p>​    服务端：Docker守护进程，负责接收处理Docker指令，管理镜像，容器等。</p>
<p>​    客户端：通过命令或RestAPI发送指令到Docker服务端，可以在本地或远程发送。</p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>1.Linux安装Docker</p>
<p>参考:<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 卸载之前的docker</span><br><span class="line"> sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">                  </span><br><span class="line"># 2.需要的安装包</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"># 3.设置镜像的仓库</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"># 默认是从国外的，不推荐</span><br><span class="line"># 推荐使用国内的</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"># 更新yum软件包索引</span><br><span class="line">yum makecache </span><br><span class="line"></span><br><span class="line"># 4.安装docker相关的 docker-ce 社区版 而ee是企业版</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"># 5、启动docker</span><br><span class="line">docker systemctl start docker</span><br><span class="line"># 6. 使用docker version查看是否按照成功</span><br><span class="line">docker version</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.配置镜像加速器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://2lxyghvy.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><p>镜像分为两部分，[repository]:[tag] 如mysql:5.7</p>
<p>如果没有指定tag时，默认为最新版本镜像。</p>
<h3 id="镜像操作命令"><a href="#镜像操作命令" class="headerlink" title="镜像操作命令"></a>镜像操作命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build 本地构建镜像</span><br><span class="line">docker pull 从服务器拉取镜像     docker push</span><br><span class="line">docker images 查看镜像</span><br><span class="line">docker rmi 删除镜像</span><br><span class="line">docker save 保存镜像为一个压缩包   docker load 加载压缩包为镜像</span><br><span class="line">//查看哪个命令是干嘛的：docker images --help </span><br></pre></td></tr></table></figure>



<h3 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h3><p>docker pause   docker unpause</p>
<p>docker  stop    docker start </p>
<p>docker logs 查看容器运行日志</p>
<p>docker ps 查看所有运行的容器及状态</p>
<p>docker exec 进入容器执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤一： 去docker hub查看nginx的容器运行命令</span><br><span class="line">docker run --name containeName -p 80:80 -d nginx </span><br><span class="line">命令解读：</span><br><span class="line">docker run创建并运行一个容器</span><br><span class="line">	--name ：给容器起一个名字，比如叫做run</span><br><span class="line">	--p : 将宿主机端口和容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</span><br><span class="line">	--d :后台运行容器</span><br><span class="line">	nginx: 镜像名称，例如nginx</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">案例：进入nginx容器，修改html文件内容，添加“传智教育欢迎你”</span><br><span class="line">步骤一：进入容器，进入我们刚刚创建的nginx容器的命令为：</span><br><span class="line">docker exec --it mn bash</span><br><span class="line">命令解读：</span><br><span class="line">docker exec: 进入容器内部，执行一个命令</span><br><span class="line">  --it :给当前进入的容器创建一个标准输入，输出终端，允许我们与容器交互</span><br><span class="line">  mn: 要进入的容器的名称</span><br><span class="line">  bash: 进入容器后执行的命令，bash是一个linux终端交互命令</span><br></pre></td></tr></table></figure>



<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>容器与数据耦合的问题：不便于修改。</p>
<p>数据卷（volume)是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p>数据卷的作用：将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作数据卷</span><br><span class="line">基本语法如下：</span><br><span class="line">docker volume [COMMAND]</span><br><span class="line">docker volume 命令是数据卷操作，根据命令后跟随的command来确定下一步的操作</span><br><span class="line">	create 创建一个volume</span><br><span class="line">	inspect 显示一个或多个volume的信息</span><br><span class="line">	ls   列出所有的volume</span><br><span class="line">	prune 删除未使用的volume</span><br><span class="line">	rm   删除一个或多个指定的volume</span><br></pre></td></tr></table></figure>



<h3 id="Docker基本操作"><a href="#Docker基本操作" class="headerlink" title="Docker基本操作"></a>Docker基本操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp aaa-DDL.sql mysql:/opt/</span><br><span class="line">docker exec -it mysql bash</span><br><span class="line">docker logs -f --tail=200f proxy-service</span><br><span class="line">tail -300f hospital-qqq.log</span><br><span class="line">ps -ef |grep java</span><br><span class="line">systemctl start qqq.jar</span><br></pre></td></tr></table></figure>



<p>挂载数据卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们在创建容器时，可以通过-v参数来挂载一个数据卷到某个容器目录</span><br><span class="line">docker run\  创建并运行容器</span><br><span class="line"> --name mn\  给容器起个名字叫mn</span><br><span class="line"> -v html:/root/html\	-v html:/root/htm: 把html数据卷挂载到容器内的/root/html/这个目录中</span><br><span class="line"> -p 8080:80		把宿主机的8080端口映射到容器内的80端口</span><br><span class="line"> nginx \	镜像名称</span><br></pre></td></tr></table></figure>





<h1 id="DockerCompose部署微服务集群"><a href="#DockerCompose部署微服务集群" class="headerlink" title="DockerCompose部署微服务集群"></a>DockerCompose部署微服务集群</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</span><br><span class="line"> version:&#x27;3.0&#x27;</span><br><span class="line"> services:</span><br><span class="line">    registry:</span><br><span class="line">        image:registry</span><br><span class="line">        volumes:</span><br><span class="line">            - ./registry-data:/var/lib/registry</span><br><span class="line">    ui:</span><br><span class="line">        image:joxit/docker-registry-ui:static</span><br><span class="line">        ports:</span><br><span class="line">            - 8080:80</span><br><span class="line">        environment:</span><br><span class="line">            - REGISTRY._TITLE=传智教育私有仓库</span><br><span class="line">            - REGISTRY_URL=http://registry:5000</span><br><span class="line">    	depends_on:</span><br><span class="line">            - registry</span><br></pre></td></tr></table></figure>



<p>各自打好jar包丢在目标父工程的对应微服务里（和DockerFile同级），然后docker-compose 执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.推送本地镜像到仓库前都必须重命名（docker tag）镜像，以镜像仓库地址为前缀</span><br><span class="line">2.镜像仓库推送前需要把仓库地址配置到docker服务的daemon，json文件中，被docker信任</span><br><span class="line">3.推送使用docker push命令</span><br><span class="line">4.拉取使用docker pull命令</span><br></pre></td></tr></table></figure>





<h2 id="Dockerfile自定义镜像结构"><a href="#Dockerfile自定义镜像结构" class="headerlink" title="Dockerfile自定义镜像结构"></a>Dockerfile自定义镜像结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">镜像是分层结构，每一层成为一个Layer</span><br><span class="line">BaseImage层：包含基本的系统函数库，环境变量，文件系统。</span><br><span class="line">Entrypoint: 入口，是镜像中应用启动的命令</span><br><span class="line">其他：在BaseImage基础上添加依赖，安装程序，完成整个应用的安装和配置。</span><br></pre></td></tr></table></figure>

<p>自定义镜像：</p>
<p>Dockerfile文件编写，里面包含一个个的指令，用指令说明要执行什么操作要构建镜像，每个指令会形成一层Layer</p>
<p>Dockerfile就是一个文本文件，其中包含一个个的指令（Instruction），用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定基础镜像</td>
<td>FROM centos:6</td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量，可在后面指令使用</td>
<td>ENV key value</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝本地文件到镜像的指定目录</td>
<td>COPY ./mysql-5.7.rpm /tmp</td>
</tr>
<tr>
<td>RUN</td>
<td>执行Linux的shell命令，一般是安装过程的命令</td>
<td>RUN yum install gcc</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>指定容器运行时监听的端口，是给镜像使用者看的</td>
<td>EXPOSE 8080</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>镜像中应用的启动命令，容器运行时调用</td>
<td>ENTRYPOINT java -jar xx.jar</td>
</tr>
</tbody></table>
<h2 id="构建Docker镜像"><a href="#构建Docker镜像" class="headerlink" title="构建Docker镜像"></a>构建Docker镜像</h2><p>1.打jar包跳过测试，模块下创建docker文件夹，把jar包丢进去</p>
<p>2.docker文件夹下建立Dockerfile文件，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line">ENV wordic=/root/wh2106/eurek-server</span><br><span class="line">COPY .$&#123;Workdir&#125;</span><br><span class="line">WORKDIR $&#123;workdir&#125;</span><br><span class="line">EXPOSE 8761</span><br><span class="line">CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;jar包名字&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.docker命令下新建脚本run.sh</p>
<p>cd ..&amp;&amp; docker build ./eureka -server  -t eureka-server:1.0 </p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>代码规范</title>
    <url>/2022/11/16/CodeRules/</url>
    <content><![CDATA[<p>参考： <a href="https://mp.weixin.qq.com/s?__biz=MzU1Nzg4NjgyMw==&mid=2247503884&idx=1&sn=6bec3003e888dcc450df335a868d4f21&chksm=fc2c6c04cb5be5121cd4f07a4ee3174e19b7718f27ff6d0c06e8fbb918f3e888c9b888cbff5a&scene=27&key=9b3cc3e1916667b5f1d57981f060580238582ca6379336de1435bb76c2b5f3d4b2245d7242be1d15d0df7cae32ac3fad8284e46dd194046b6af9874a113572340cd5e8ddb89be8bc75c8b35da2da53607089869e5437da6fa6a028e80419d641a23aae9508c5641984b3bc08ed1d12f7c5dc0060ef559ae867c7d2757f1cfc9d&ascene=7&uin=MTI4ODQxNzM5MA==&devicetype=Windows+11+x64&version=63080021&lang=zh_CN&session_us=gh_433697c99b25&exportkey=n_ChQIAhIQo3RBb0zuO3e3m8ArlcJ7MBLgAQIE97dBBAEAAAAAAJVeBrAua+QAAAAOpnltbLcz9gKNyK89dVj0CM6Cdi8QpnjG0EX7pNCrpXPTPlv+e1EMXDmL32Mz+tjUiu2DFwa2JVEcMyCsn3H/oYOZSrZfPP9yhDYG+G00MgAgZYyrRc33iaq/8rfGLb1b85hBm0imJ1qiWSeXTvsg4WRmjU4DV3HKL/08dgqbcvgOigibGN79XClARt5s4h+o7l6VKa3qXCV0evV1soH5CvN1vmmUljI5/yo5vriSFKWE2Khh3Qp1ip5MT6UJbBY3RqT7RxCjdUiI&acctmode=0&pass_ticket=Gm0pnGnWu4IjkZOm1o/voE5cVlFJrbJYg4tF3kbjDhtYiiL7Z/Lbid6wFfK26rc8&wx_header=0&fontgear=2">前同事写的代码太坑？试试这些代码技巧，用上之后绝对优雅！ (qq.com)</a></p>
]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos SpringCloud</title>
    <url>/2022/11/24/Nacos-SpringCloud/</url>
    <content><![CDATA[<p>未完成</p>
<h1 id="Nacos-Spring-Cloud"><a href="#Nacos-Spring-Cloud" class="headerlink" title="Nacos Spring Cloud"></a>Nacos Spring Cloud</h1><p>安装：下载安装包 ,解压 ,bin目录下执行startup.cmd -m standlone</p>
<h2 id="启动配置管理"><a href="#启动配置管理" class="headerlink" title="启动配置管理"></a>启动配置管理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、如何使用Nacos作为配置中心统一管理配置</span><br><span class="line">	1）、引入依赖，</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">   		&lt;groupId&gt;com.alibaba.cLoud&lt;/groupId&gt;</span><br><span class="line">   		&lt;artifactId&gt;spring-cLoud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	2）、创建一个bootstrap，properties.</span><br><span class="line">		spring.application.name=gulimall-coupon</span><br><span class="line">		spring.cLoud.nacos.config.server-addr=127.0.0.1:8848</span><br><span class="line">        </span><br><span class="line">3)需要给配置中心默认添加一个叫数据集（Data Id）gulimall-coupon，.properties。默认规则，应用名.properties</span><br><span class="line">4）、给应用名，properties添加任何配置</span><br><span class="line">5）、动态获取配置。</span><br><span class="line">	@RefreshScope：动态获取并刷新配置</span><br><span class="line">	@Value（&quot;$配置项的名&#125;&quot;）：获取到配置。</span><br><span class="line">如果配置中心和当前应用的配置文件中都配置了相同的项，优先使用配置中心的配置。</span><br><span class="line">2、细节</span><br><span class="line">	1）、命名空间：配置隔离：</span><br><span class="line">		默认：public（保留空间）；默认新增的所有配置都在public空间。</span><br><span class="line">		1、开发，测试，生产：利用命名空间来做环境隔离。</span><br><span class="line">		注意：在bootstrap，properties；配置上，需要使用哪个命名空间下的配置，</span><br><span class="line">		spring.cLoud.nacos.config.namespace=9de62e44-cd2a-4a82-bf5c-95878bd5e871</span><br><span class="line">		2、每一个微服务之间互相隔离配置，每一个微服务都创建自己的命名空间，只加载自己命名空间下的所有配置</span><br><span class="line">	2）、配置集：所有的配置的集合</span><br><span class="line">	3）、配置集ID：类似文件名。</span><br><span class="line">		Data ID:类似文件名</span><br><span class="line">	4）、配置分组：</span><br><span class="line">		默认所有的配置都属于:DEFAULT_GROUP</span><br><span class="line">		1111 618  1212 	</span><br><span class="line">项目中的使用，每个微服务创建自己的命名空间，使用配置分组区分环境，dev,test,prod</span><br><span class="line"></span><br><span class="line">3、同时加载多个配置集</span><br><span class="line">	1）、微服务任何配置信息，任何配置文件都可以放在配置中心中。</span><br><span class="line">			配置优先级：服务名-profile.yaml&gt; 服务名.yaml &gt;本地配置</span><br><span class="line">	2）、只需要在bootstrap，properties说明加载配置中心中哪些配置文件即可</span><br><span class="line">	3）、热更新： @Value，@ConfigurationProperties</span><br><span class="line">	</span><br><span class="line">以前SpringBoot任何方法从配置文件中获取值，都能使用。</span><br><span class="line">配置中心有的优先使用配置中心中的。</span><br></pre></td></tr></table></figure>



<p>案例：</p>
<p>1.common中添加依赖 nacos配置中心</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.在coupons项目中创建/src/main/resources/bootstrap.yml，优先级别application.properties高</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改名字，对应nacos里的配置文件名</span></span><br><span class="line"> <span class="string">//案例：</span></span><br><span class="line">    <span class="comment"># 改名字，对应nacos里的配置文件名</span></span><br><span class="line">    <span class="attr">spring:</span></span><br><span class="line">      <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">gulimall-coupon</span>  <span class="comment">#服务名称</span></span><br><span class="line">      <span class="attr">profiles:</span></span><br><span class="line">        <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev</span></span><br><span class="line">      <span class="attr">cloud:</span></span><br><span class="line">        <span class="attr">nacos:</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment">#nacos地址</span></span><br><span class="line">            <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 指定配置文件为yaml格式</span></span><br><span class="line"><span class="string">//服务名-环境-后缀名就是data</span> <span class="string">ID</span></span><br></pre></td></tr></table></figure>

<p>3、浏览器去nacos里的配置列表，点击＋号，data ID：<code>gulimall-coupon.yaml</code>，配置</p>
<p>4.在controller中编写测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;coupon.user.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;coupon.user.age&#125;&quot;)</span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/nacos&quot;)</span><br><span class="line">public R nacos()&#123;</span><br><span class="line">    return R.ok().put(&quot;name&quot;, name).put(&quot;age&quot;, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:7000/coupon/coupon/nacos</span><br></pre></td></tr></table></figure>

<p>6.在coupon的控制层上加<code>@RefreshScope</code>支持动态刷新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例：</span><br><span class="line">		方式一：在@Value注入的变量所在类上添加注解@RefreshScope</span><br><span class="line">        对应@Value注入的变量。</span><br><span class="line">        @Value(&quot;$&#123;pattern.dataformat&#125;&quot;)</span><br><span class="line">        private String dateformat;</span><br><span class="line"></span><br><span class="line">        方式二：使用@ConfigurationProperties注解(约定大于配置) 自动刷新</span><br><span class="line">        @Configurationperties(prefix=&quot;pattern&quot;)</span><br><span class="line">        public class PatternProperties&#123;</span><br><span class="line">            private String dateformat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7.新建coupon、member、order、product、ware五个命名空间分别保存自己的配置文件</p>
<p>nacos说明：<br>最终方案：每个微服务创建自己的命名空间，然后使用配置分组区分环境（dev/test/prod)</p>
<h2 id="启动服务发现"><a href="#启动服务发现" class="headerlink" title="启动服务发现"></a>启动服务发现</h2><p>1.添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;latest.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>2.配置服务提供者，从而服务提供者可以通过 Nacos 的服务注册发现功能将其服务注册到 Nacos server 上。</p>
<p>i .在 <code>application.properties</code> 中配置 Nacos server 的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=8070 </span><br><span class="line">spring.application.name=service-provider spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</span><br></pre></td></tr></table></figure>



<p>ii. 通过 Spring Cloud 原生注解 <code>@EnableDiscoveryClient</code> 开启服务注册发现功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class NacosProviderApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(NacosProviderApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@RestController</span><br><span class="line">	class EchoController &#123;</span><br><span class="line">		@RequestMapping(value = &quot;/echo/&#123;string&#125;&quot;, method = RequestMethod.GET)</span><br><span class="line">		public String echo(@PathVariable String string) &#123;</span><br><span class="line">			return &quot;Hello Nacos Discovery &quot; + string;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>配置服务消费者，从而服务消费者可以通过 Nacos 的服务注册发现功能从 Nacos server 上获取到它要调用的服务。</li>
</ol>
<p>i. 在 <code>application.properties</code> 中配置 Nacos server 的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port=8080</span><br><span class="line">spring.application.name=service-consumer</span><br><span class="line"></span><br><span class="line">spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</span><br></pre></td></tr></table></figure>

<p>ii. 通过 Spring Cloud 原生注解 <code>@EnableDiscoveryClient</code> 开启服务注册发现功能。给 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-resttemplate.html">RestTemplate</a> 实例添加 <code>@LoadBalanced</code> 注解，开启 <code>@LoadBalanced</code> 与 <a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-ribbon.html">Ribbon</a> 的集成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class NacosConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">    @LoadBalanced</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(NacosConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RestController</span><br><span class="line">    public class TestController &#123;</span><br><span class="line"></span><br><span class="line">        private final RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">        @Autowired</span><br><span class="line">        public TestController(RestTemplate restTemplate) &#123;this.restTemplate = restTemplate;&#125;</span><br><span class="line"></span><br><span class="line">        @RequestMapping(value = &quot;/echo/&#123;str&#125;&quot;, method = RequestMethod.GET)</span><br><span class="line">        public String echo(@PathVariable String str) &#123;</span><br><span class="line">            return restTemplate.getForObject(&quot;http://service-provider/echo/&quot; + str, String.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>启动 <code>ProviderApplication</code> 和 <code>ConsumerApplication</code> ，调用 <code>http://localhost:8080/echo/2018</code>，返回内容为 <code>Hello Nacos Discovery 2018</code>。</li>
</ol>
<h1 id="服务分级存储模型"><a href="#服务分级存储模型" class="headerlink" title="服务分级存储模型"></a>服务分级存储模型</h1><h3 id="服务集群属性："><a href="#服务集群属性：" class="headerlink" title="服务集群属性："></a>服务集群属性：</h3><p>服务-&gt;集群-&gt;实例，</p>
<p>如何修改集群属性：修改application.yml文件，添加cluster-name属性即可。</p>
<p>1.修改application.yml ,添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            server-addr: localhost:8848 #nacos服务端地址</span><br><span class="line">            discovery:</span><br><span class="line">                cluster-name: HZ #配置集群名称，也就是机房位置，例如：HZ，杭州</span><br></pre></td></tr></table></figure>

<p>2.在nacos控制台可以看到集群变化（集群HZ)</p>
<h3 id="根据集群负载均衡"><a href="#根据集群负载均衡" class="headerlink" title="根据集群负载均衡"></a>根据集群负载均衡</h3><p>1.修改order-service中的application.yml，设置集群为HZ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            server-addr: localhost:8848 #nacos服务端地址</span><br><span class="line">            discovery:</span><br><span class="line">                cluster-name: HZ #配置集群名称，也就是机房位置，例如：HZ，杭州</span><br></pre></td></tr></table></figure>

<p>这里orderservice是服务调用者。</p>
<p>2.然后在order-service中设置负载均衡的IRlue为NacosRule,这个规则会优先寻找自己同集群的服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userservice:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则</span><br></pre></td></tr></table></figure>



<p>NacosRule负载均衡策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、会优先选择同集群服务示例列表</span><br><span class="line">2、本地集群找不到提供者，才会去其它集群寻找，并且会报警告</span><br><span class="line">3、确定了可用实例列表后，再采用随机负载均衡挑选示例</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>Nacos SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Git相关</title>
    <url>/2022/11/16/Git%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>git  config –global user.name “aaa” 设置用户信息</p>
<p>git config –global user.email “<a href="mailto:&#x61;&#x61;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;">&#x61;&#x61;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;</a>“</p>
<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>git config –global user.name</p>
<p>git config –global user.email </p>
<h1 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h1><p>git init     初始化仓库</p>
<p>git commit    提交到本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --m &#x27;update file01&#x27;	将修改提交到本地仓库，提交记录为update file01</span><br></pre></td></tr></table></figure>

<p>git add .    加入暂存区  </p>
<p>git reset     取消暂存</p>
<p>git status     查看修改的状态</p>
<p>git log     查看提交日志</p>
<p>git reset –hard  commitID       版本回退(commitID可以用git-log 或git log查看)</p>
<p>git reflog     查看已删除的记录</p>
<p>git remote     查看远程仓库( 如果是origin就是连接到了远程仓库)</p>
<p>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;  添加远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:lsdlife/JavaBase.git</span><br></pre></td></tr></table></figure>

<p>git clone  * 从远程仓库克隆</p>
<p>git pull （orgin master)从远程仓库拉取</p>
<p>git push  orgin master 推送到远程仓库</p>
<p>git branch 查看本地分支</p>
<p>git branch * 创建本地分支</p>
<p>git branch -r 列出所有远程分支</p>
<p>git branch -a 列出所有本地分支和远程分支</p>
<p>git checkout * 切换分支</p>
<p>git checkout -b * 直接切换到一个不存在的分支（创建并切换）</p>
<p>git branch -d  *     删除分支，需要做各种检查</p>
<p>git branch -D *      不做任何检查，强制删除</p>
<p>git push origin * 推送至远程仓库分支</p>
<p>git merge * 合并分支</p>
<h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>1.解决文件中冲突的地方</p>
<p>2.将解决完冲突的文件中加入暂存区（add)</p>
<p>3.提交到仓库（commit)</p>
<h1 id="idea-界面"><a href="#idea-界面" class="headerlink" title="idea 界面"></a>idea 界面</h1><p>Terminal界面输入相关指令。</p>
<p> get from version control </p>
<p>创建分支 new branch   </p>
<p>创建新文件的时候，会自动提示add  </p>
<p>提交（每次先进行拉取）的同时 点击推送 commit and push </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis和MybatisPlus的使用</title>
    <url>/2022/11/16/Mybatis%E5%92%8CMybatisPlus%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>未完成…….</p>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h3 id="面试题参考："><a href="#面试题参考：" class="headerlink" title="面试题参考："></a>面试题参考：</h3><p><a href="http://topjavaer.cn/framework/mybatis.html">程序员大彬 (topjavaer.cn)</a></p>
<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h3 id="几个好用的封装注解："><a href="#几个好用的封装注解：" class="headerlink" title="几个好用的封装注解："></a>几个好用的封装注解：</h3>]]></content>
      <tags>
        <tag>Mybatis MybatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign</title>
    <url>/2022/12/14/OpenFeign/</url>
    <content><![CDATA[<p>未完成</p>
<p>声明式远程调用</p>
<p>feign是一个声明式的HTTP客户端，他的目的就是让远程调用更加简单。给远程服务发的是HTTP请求。</p>
<p>会员服务想要远程调用优惠券服务，只需要给会员服务里引入openfeign依赖，他就有了远程调用其他服务的能力。</p>
<p>1.引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>2.演示member服务调用coupon服务</p>
<p>在gulimall-coupon中的CouponController中添加测试方法</p>
<pre><code>@RequestMapping(&quot;/member/list&quot;)
public R membercoupons()&#123;    //全系统的所有返回都返回R
    // 模拟去数据库查用户对于的优惠券
    CouponEntity couponEntity = new CouponEntity();
    couponEntity.setCouponName(&quot;满100-10&quot;);//优惠券的名字
    return R.ok().put(&quot;coupons&quot;,Arrays.asList(couponEntity));
&#125;
</code></pre>
<p>在member的主启动类上加注解@EnableDiscoveryClient，告诉member是一个远程调用客户端，member要调用东西的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients(basePackages=&quot;com.xmh.gulimall.member.feign&quot;)//扫描接口方法注解</span><br><span class="line">public class GulimallMemberApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GulimallMemberApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在com.xmh.gulimall.member.feign中新建接口CouponFeignService</p>
<pre><code>@FeignClient(&quot;gulimall-coupon&quot;)//告诉spring cloud这个接口是一个远程客户端，要调用coupon服务(nacos中找到)
public interface CouponFeignService &#123;
// 远程服务的url
@RequestMapping(&quot;/coupon/coupon/member/list&quot;)//注意写全优惠券类上还有映射
public R membercoupons();//得到一个R对象
&#125;
</code></pre>
<p>在member的MemberController写一个测试</p>
<pre><code>@Autowired
private CouponFeignService couponFeignService; //注入刚才的CouponFeignService接口

@RequestMapping(&quot;/coupons&quot;)
public R coupons()&#123;
    MemberEntity memberEntity = new MemberEntity();
    memberEntity.setNickname(&quot;会员昵称张三&quot;);
    R membercoupons = couponFeignService.membercoupons();

    return R.ok().put(&quot;member&quot;, memberEntity).put(&quot;coupons&quot;, membercoupons.get(&quot;coupons&quot;));
&#125;
</code></pre>
<h2 id="Http客户端-Feign"><a href="#Http客户端-Feign" class="headerlink" title="Http客户端 Feign"></a>Http客户端 Feign</h2><p>主要是用来替换如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//2利用RestTemplate发起http请求，查询用户</span><br><span class="line">//2.1 url路径</span><br><span class="line">String url=&quot;http://userservice/user/&quot;+order.getUserId();</span><br><span class="line">//2.2 发送http请求，实现远程调用</span><br><span class="line">User user=restTemplate.getForObject(url,User.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意:feign是微服务内部之间直接调用。</p>
<h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p>使用Feign的步骤如下：</p>
<p>1.调用发出者引入openfeign依赖 </p>
<p>2.调用发出者添加注解开启Feign的功能</p>
<p>@EnableFeignClients</p>
<p>3.编写Feignk客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(&quot;userservice&quot;)  #指定服务名称，一般是服务提供者，用来发送http请求</span><br><span class="line">public interface UserClient&#123;</span><br><span class="line">	@GetMapping(&quot;/user/&#123;id&#125;&quot;)	#可变</span><br><span class="line">	User findById(@PathVarliable (&quot;id&quot;) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>想要远程调用别的服务：</p>
<p>1）引入open-feign</p>
<p>2）编写一个接口，告诉springcloud这个接口需要调用原创服务</p>
<p>​        1）声明接口的每一个方法都是调用哪个远程服务的那个请求</p>
<p>3）。开启远程调用功能</p>
<p>主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p>
<p>服务名称：userservice</p>
<p>请求方式：GET</p>
<p>请求路径：/user/{id}</p>
<p>请求参数：Long id</p>
<p>返回值类型：User</p>
<h3 id="配置Feign日志"><a href="#配置Feign日志" class="headerlink" title="配置Feign日志"></a>配置Feign日志</h3><p>1.全局生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line"> client:</span><br><span class="line">  config:</span><br><span class="line">   default: #这里用default就是全局配置，如果写服务名称，则是针对某个微服务的配置 如改成userservice</span><br><span class="line">   loggerLevel:FULL #日志级别</span><br></pre></td></tr></table></figure>



<h3 id="自定义Feign的配置"><a href="#自定义Feign的配置" class="headerlink" title="自定义Feign的配置"></a>自定义Feign的配置</h3><p>走Java代码方式，需要先声明一个Bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FeignClientConfiguration&#123;</span><br><span class="line">	@Bean </span><br><span class="line">	public Logger.Level.feignLogLevel()&#123;</span><br><span class="line">		return Logger.Level.BASIC;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.而后如果是全局配置，则把它放到@EnableFeignClients这个注解中</p>
<p>(就是放在该启动类上)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(defaultConfiguration=FeignClientConfiguration.class)</span><br></pre></td></tr></table></figure>

<p>2.如果是局部配置，则把它放到@FeignClient这个注解中</p>
<p>(就是放在之前UserClient那的地方)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(value=&quot;userservice&quot;,configuration=FeignClientConfiguration.class)</span><br></pre></td></tr></table></figure>





<h3 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h3><p>Feign添加HttpClient的支持</p>
<p>引入依赖：feign-httpClient</p>
<p>配置连接池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line"> client:</span><br><span class="line">  config:</span><br><span class="line">   default: #default全局的配置</span><br><span class="line">    loggerlevel:BASIC #日志级别,BASIC就是基本的请求和相应消息</span><br><span class="line"> httpclient:</span><br><span class="line">  enabled:true #开启feign对HttpClient的支持</span><br><span class="line">  max-connections:200 #最大的连接数</span><br><span class="line">  max-connections-per-route:50 #每个路径的最大连接数</span><br></pre></td></tr></table></figure>



<h3 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h3><p>方式一： （继承）</p>
<p>给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。(有紧耦合问题)</p>
<p>方案二：(抽取)：</p>
<p>将FeignClient抽取为独立模块，并且把接口有关的POJO,默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p>
<p>(使用的时候引依赖)</p>
<p>实现步骤：</p>
<p>1.首先创建一个module,命名为feign-api,然后引入feign的starter依赖</p>
<p>2.将order-service中编写的UserClient，User,DefaultFeignConfiguration都复制到feign-api项目中。</p>
<p>3.在order-service中引入feign-api的依赖</p>
<p>4.修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包</p>
<p>5.重启测试</p>
<p>此时定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用，有两种方式解决：</p>
<p>方式一：指定FeignClient所在包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(basePackages=&quot;cn.itcast.feign.clients&quot;)</span><br></pre></td></tr></table></figure>

<p>方式二：指定FeignClient字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients(clients=&#123;UserClient.class&#125;)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的相关知识</title>
    <url>/2022/11/18/MySQL%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="1-SQL语句分类"><a href="#1-SQL语句分类" class="headerlink" title="1. SQL语句分类"></a>1. SQL语句分类</h1><p>根据其功能，主要分为四类：</p>
<table>
<thead>
<tr>
<th>分 类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据定义语言，用来定义数据库对象(数据库，表， 字段)</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td>
</tr>
</tbody></table>
<h1 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询所有数据库：</span><br><span class="line">show databases ;</span><br><span class="line"></span><br><span class="line">#查询当前数据库：</span><br><span class="line">select database() ;</span><br><span class="line"></span><br><span class="line">#创建数据库：</span><br><span class="line">create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</span><br><span class="line">//create database itheima default charset utf8mb4;</span><br><span class="line"></span><br><span class="line">#删除数据库：</span><br><span class="line">drop database [ if exists ] 数据库名 ;</span><br><span class="line">#使用数据库：</span><br><span class="line">use 数据库名 ;</span><br><span class="line"></span><br><span class="line">#新建schema</span><br><span class="line">create schema db01;</span><br></pre></td></tr></table></figure>





<h1 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3 表操作"></a>3 表操作</h1><h2 id="3-1-添加数据"><a href="#3-1-添加数据" class="headerlink" title="3.1 添加数据"></a>3.1 添加数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询当前数据库所有表：</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">#查看指定表结构</span><br><span class="line">desc 表名 ;</span><br><span class="line"></span><br><span class="line">#创建表：</span><br><span class="line">CREATE TABLE 表名(    </span><br><span class="line">字段1 字段1类型 [COMMENT 字段1注释],    </span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释],   </span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释],  </span><br><span class="line">...    </span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br><span class="line">//</span><br><span class="line">create table tb_user(</span><br><span class="line">id int comment &#x27;编号&#x27;,</span><br><span class="line">name varchar(50) comment &#x27;姓名&#x27;,</span><br><span class="line">age int comment &#x27;年龄&#x27;,</span><br><span class="line">gender varchar(1) comment &#x27;性别&#x27;</span><br><span class="line">) comment &#x27;用户表&#x27;;</span><br><span class="line"></span><br><span class="line">#查询指定表的建表语句：</span><br><span class="line">show create table 表名 ;</span><br><span class="line"></span><br><span class="line">#给指定字段添加数据</span><br><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...)</span><br><span class="line">#案例: 给employee表所有的字段添加数据 ；</span><br><span class="line">insert into employee(id,workno,name,gender,age,idcard,entrydate) values(1,&#x27;1&#x27;,&#x27;Itcast&#x27;,&#x27;男&#x27;,10,&#x27;123456789012345678&#x27;,&#x27;2000-01-01&#x27;);</span><br><span class="line"></span><br><span class="line">#给全部字段添加数据</span><br><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br><span class="line">案例：插入数据到employee表，具体的SQL如下：</span><br><span class="line">insert into employee values(2,&#x27;2&#x27;,&#x27;张无忌&#x27;,&#x27;男&#x27;,18,&#x27;123456789012345670&#x27;,&#x27;2005-01-</span><br><span class="line">01&#x27;);</span><br><span class="line"></span><br><span class="line">#批量添加数据</span><br><span class="line">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值 1, 值2, ...) ;</span><br><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</span><br><span class="line">#案例：批量插入数据到employee表，具体的SQL如下：</span><br><span class="line">insert into employee values(3,&#x27;3&#x27;,&#x27;韦一笑&#x27;,&#x27;男&#x27;,38,&#x27;123456789012345670&#x27;,&#x27;2005-01-</span><br><span class="line">01&#x27;),(4,&#x27;4&#x27;,&#x27;赵敏&#x27;,&#x27;女&#x27;,18,&#x27;123456789012345670&#x27;,&#x27;2005-01-01&#x27;);</span><br></pre></td></tr></table></figure>



<h2 id="3-2-删除数据"><a href="#3-2-删除数据" class="headerlink" title="3.2 删除数据"></a>3.2 删除数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除表</span><br><span class="line">DROP TABLE [ IF EXISTS ] 表名</span><br><span class="line">#如果tb_user表存在，则删除tb_user表</span><br><span class="line">DROP TABLE IF EXISTS tb_user;</span><br><span class="line"></span><br><span class="line">#删除指定表, 并重新创建表</span><br><span class="line">TRUNCATE TABLE 表名</span><br><span class="line"></span><br><span class="line">#删除数据的具体语法为：</span><br><span class="line">DELETE FROM 表名 [ WHERE 条件 ] </span><br><span class="line"></span><br><span class="line">#删除gender为女的员工</span><br><span class="line">delete from employee where gender = &#x27;女&#x27;;</span><br><span class="line"></span><br><span class="line">#删除所有员工</span><br><span class="line">delete from employee</span><br></pre></td></tr></table></figure>



<h2 id="3-3-修改数据"><a href="#3-3-修改数据" class="headerlink" title="3.3 修改数据"></a>3.3 修改数据</h2><h3 id="3-3-1-alter"><a href="#3-3-1-alter" class="headerlink" title="3.3.1  alter"></a>3.3.1  alter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加字段</span><br><span class="line">ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="line"></span><br><span class="line">#为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20) </span><br><span class="line">ALTER TABLE emp ADD nickname varchar(20) COMMENT &#x27;昵称&#x27;;</span><br><span class="line"></span><br><span class="line">#修改数据类型</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度);</span><br><span class="line"></span><br><span class="line">#修改字段名和字段类型</span><br><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="line"></span><br><span class="line">#将emp表的nickname字段修改为username，类型为varchar(30)</span><br><span class="line">ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#x27;昵称&#x27;;</span><br><span class="line"></span><br><span class="line">#删除字段</span><br><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br><span class="line"></span><br><span class="line">#将emp表的字段username删除</span><br><span class="line">ALTER TABLE emp DROP username;</span><br><span class="line"></span><br><span class="line">#修改表名</span><br><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br><span class="line"></span><br><span class="line">#将emp表的表名修改为 employee</span><br><span class="line">ALTER TABLE emp RENAME TO employee;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-2-update"><a href="#3-3-2-update" class="headerlink" title="3.3.2  update"></a>3.3.2  update</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改数据的具体语法为:</span><br><span class="line">UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</span><br><span class="line"></span><br><span class="line">#修改id为1的数据，将name修改为itheima</span><br><span class="line">update employee set name = &#x27;itheima&#x27; where id = 1;</span><br><span class="line"></span><br><span class="line">#修改id为1的数据, 将name修改为小昭, gender修改为 女</span><br><span class="line">update employee set name = &#x27;小昭&#x27; , gender = &#x27;女&#x27; where id = 1;</span><br><span class="line"></span><br><span class="line">#将所有的员工入职日期修改为 2008-01-01</span><br><span class="line">update employee set entrydate = &#x27;2008-01-01&#x27;;</span><br></pre></td></tr></table></figure>





<h2 id="3-4-单表查询"><a href="#3-4-单表查询" class="headerlink" title="3.4 单表查询"></a>3.4 单表查询</h2><h3 id="3-4-1-基本查询"><a href="#3-4-1-基本查询" class="headerlink" title="3.4.1 基本查询"></a>3.4.1 基本查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">基础查询</span><br><span class="line"></span><br><span class="line">#查询多个字段</span><br><span class="line">SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</span><br><span class="line"></span><br><span class="line">#字段设置别名</span><br><span class="line">SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</span><br><span class="line"></span><br><span class="line">#去除重复记录</span><br><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">聚合函数查询</span><br><span class="line"></span><br><span class="line">SELECT 聚合函数(字段列表) FROM 表名 ;</span><br><span class="line">//注意 : NULL值是不参与所有聚合函数运算的。</span><br><span class="line"></span><br><span class="line">#对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计 查询，比如：</span><br><span class="line">select count(1) from emp;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">分组查询</span><br><span class="line"></span><br><span class="line">SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组</span><br><span class="line">后过滤条件 ];</span><br><span class="line">#查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">select workaddress, count(*)  address_count from emp where age &lt; 45 group by</span><br><span class="line">workaddress having address_count &gt;= 3;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">分页查询</span><br><span class="line"></span><br><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h3 id="3-4-2-执行顺序"><a href="#3-4-2-执行顺序" class="headerlink" title="3.4.2 执行顺序"></a>3.4.2 执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DQL语句的执行顺序为： from ... where ... group by ... having ... select ... order by ... limit ...</span><br><span class="line"></span><br><span class="line">//where和having区别</span><br><span class="line">执行时机不同：where是分组前进行过滤，不满足where的不参与分组，having是分组之后对结果进行过滤</span><br><span class="line">判断条件不同：where不能对聚合函数进行判断，而having可以</span><br><span class="line">执行顺序: where &gt; 聚合函数 &gt; having 。</span><br><span class="line">支持多字段分组, 具体语法为 : group by columnA,columnB</span><br></pre></td></tr></table></figure>



<h3 id="3-4-3字符串类型"><a href="#3-4-3字符串类型" class="headerlink" title="3.4.3字符串类型"></a>3.4.3字符串类型</h3><p>MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//char 与 varchar:</span><br><span class="line">都可以描述字符串。</span><br><span class="line">char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。</span><br><span class="line">varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</span><br><span class="line"></span><br><span class="line">#concat : 字符串拼接 </span><br><span class="line">select concat(&#x27;Hello&#x27; , &#x27; MySQL&#x27;);</span><br><span class="line"></span><br><span class="line">#lower : 全部转小写 </span><br><span class="line">select lower(&#x27;Hello&#x27;);</span><br><span class="line"></span><br><span class="line">#upper : 全部转大写</span><br><span class="line">select upper(&#x27;Hello&#x27;);</span><br><span class="line"></span><br><span class="line">#lpad : 左填充 </span><br><span class="line">select lpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">#rpad : 右填充 </span><br><span class="line">select rpad(&#x27;01&#x27;, 5, &#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">#trim : 去除空格 </span><br><span class="line">elect trim(&#x27; Hello MySQL &#x27;)</span><br><span class="line"></span><br><span class="line">#substring : 截取子字符串 </span><br><span class="line">select substring(&#x27;Hello MySQL&#x27;,1,5);</span><br></pre></td></tr></table></figure>





<h2 id="3-5-多表查询"><a href="#3-5-多表查询" class="headerlink" title="3.5. 多表查询"></a>3.5. 多表查询</h2><h3 id="3-5-1-多表关系"><a href="#3-5-1-多表关系" class="headerlink" title="3.5.1 多表关系"></a>3.5.1 多表关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一对多 (多对一) </span><br><span class="line">案例：一个部门对应多个员工，一个员工对应一个部门</span><br><span class="line">实现: 在多的一方建立外键，指向一的一方的主键</span><br><span class="line"></span><br><span class="line"># 5.1.2 多对多</span><br><span class="line">案例：一个学生可以选修多门课程，一门课程也可以供多个学生选择</span><br><span class="line">实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</span><br><span class="line"></span><br><span class="line"># 5.1.3 一对一</span><br><span class="line">案例: 用户 与 用户详情的关系</span><br><span class="line">实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</span><br></pre></td></tr></table></figure>



<h3 id="3-5-2-内连接"><a href="#3-5-2-内连接" class="headerlink" title="3.5.2 内连接"></a>3.5.2 内连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#内连接：相当于查询A、B交集部分数据</span><br><span class="line"></span><br><span class="line">#隐式内连接： </span><br><span class="line">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</span><br><span class="line">//select e.name,d.name from emp e , dept d where e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">#显式内连接</span><br><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</span><br><span class="line">//select e.name, d.name from emp e join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-3-外连接"><a href="#3-5-3-外连接" class="headerlink" title="3.5.3 外连接"></a>3.5.3 外连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#左外连接</span><br><span class="line">#左外连接：左表+交集</span><br><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br><span class="line">//select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">#右外连接</span><br><span class="line">#右外连接：右表+交集</span><br><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br><span class="line">//select d.*, e.* from emp e right  join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-4-自连接和联合查询"><a href="#3-5-4-自连接和联合查询" class="headerlink" title="3.5.4 自连接和联合查询"></a>3.5.4 自连接和联合查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#自连接</span><br><span class="line">#自连接：当前表与自身的连接查询，可以是内连接，也可以是外连接, 自连接必须使用表别名(要给表起别名，n次)</span><br><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</span><br><span class="line">#自连接查询：</span><br><span class="line">#查询员工 及其 所属领导的名字	</span><br><span class="line">#表结构: emp</span><br><span class="line">select a.name , b.name from emp a , emp b where a.managerid = b.id</span><br><span class="line">#查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来	</span><br><span class="line">#表结构: emp a , emp b</span><br><span class="line">select a.name &#x27;员工&#x27;, b.name &#x27;领导&#x27; from emp a left join emp b on a.managerid =b.id;</span><br><span class="line">//在自连接查询中，必须要为表起别名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#联合查询</span><br><span class="line">//对于联合查询的多张表列数必须保持一致，字段类型也需要保持一致。 </span><br><span class="line">//把两张表查询的结果拼接，会有重复，union all直接合并全部数据，union会去重。</span><br><span class="line">#将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来</span><br><span class="line">select * from emp where salary &lt; 5000</span><br><span class="line">union all</span><br><span class="line">select * from emp where age &gt; 50;</span><br></pre></td></tr></table></figure>





<h3 id="3-5-5-子查询"><a href="#3-5-5-子查询" class="headerlink" title="3.5.5.子查询"></a>3.5.5.子查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#又叫嵌套查询</span><br><span class="line">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 )</span><br><span class="line"></span><br><span class="line">#分类</span><br><span class="line">#根据子查询结果不同，分为：</span><br><span class="line">A. 标量子查询：子查询结果（那个先查出来的语句）为单个值 </span><br><span class="line">B. 列子查询：子查询结果为一列  in ，not in, any ,some ,all </span><br><span class="line">C. 行子查询：子查询结果为一行</span><br><span class="line">D. 表子查询：子查询结果为多行多列。</span><br><span class="line"></span><br><span class="line">#标量子查询</span><br><span class="line">//常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;= </span><br><span class="line">#查询 &quot;销售部&quot; 的所有员工信息 </span><br><span class="line">select * from emp where dept_id = (select id from dept where name = &#x27;销售部&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#列子查询</span><br><span class="line">//常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</span><br><span class="line">#查询 &quot;销售部&quot; 和 &quot;市场部&quot; 的所有员工信息</span><br><span class="line">select * from emp where dept_id in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line">#查询比 财务部 所有人工资都高的员工信息</span><br><span class="line"> select * from emp where salary &gt; all ( select salary from emp where dept_id =</span><br><span class="line">(select id from dept where name = &#x27;财务部&#x27;) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#行子查询</span><br><span class="line">//常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</span><br><span class="line">#查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息 ;</span><br><span class="line">select * from emp where (salary,managerid) = (select salary, managerid from emp</span><br><span class="line">where name = &#x27;张无忌&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#表子查询</span><br><span class="line">//常用的操作符：IN</span><br><span class="line">#查询与 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资相同的员工信息</span><br><span class="line">select * from emp where (job,salary) in ( select job, salary from emp where name =&#x27;鹿杖客&#x27; or name = &#x27;宋远桥&#x27; );</span><br><span class="line"># 查询各部门的平均工资：</span><br><span class="line">#（select 后紧跟的子查询，表子查询）</span><br><span class="line">select  distinct  e2.dept_id,  (select avg(salary) from emp  e1 where e1.dept_id =e2.dept_id ) &#x27;平均工资&#x27; from emp e2;</span><br></pre></td></tr></table></figure>







<h2 id="4-用户和权限"><a href="#4-用户和权限" class="headerlink" title="4 用户和权限"></a>4 用户和权限</h2><h3 id="4-1-管理用户"><a href="#4-1-管理用户" class="headerlink" title="4.1 管理用户"></a>4.1 管理用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询用户</span><br><span class="line">select * from mysql.user;</span><br><span class="line"></span><br><span class="line">#创建用户</span><br><span class="line">REATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line">//在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</span><br><span class="line">//主机名可以使用 % 通配</span><br><span class="line"></span><br><span class="line">#修改用户密码</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27; ;</span><br><span class="line"></span><br><span class="line">#删除用户</span><br><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27; </span><br></pre></td></tr></table></figure>



<h3 id="4-2-权限控制"><a href="#4-2-权限控制" class="headerlink" title="4.2 权限控制"></a>4.2 权限控制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询权限</span><br><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; ;</span><br><span class="line"></span><br><span class="line">#授予权限</span><br><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">//多个权限之间，使用逗号分隔</span><br><span class="line">//授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</span><br><span class="line"></span><br><span class="line">#撤销权限</span><br><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>





<h2 id="5-约束"><a href="#5-约束" class="headerlink" title="5.约束"></a>5.约束</h2><table>
<thead>
<tr>
<th>唯一约束</th>
<th>保证该字段的所有数据都是唯一、不重复的</th>
<th>UNIQUE</th>
</tr>
</thead>
<tbody><tr>
<td>检查约束(8.0.16版本 之后)</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#外键约束</span><br><span class="line"></span><br><span class="line">#添加外键</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)</span><br><span class="line">REFERENCES 主表 (主表列名) ;</span><br><span class="line">#案例：为emp表的dept_id字段添加外键约束,关联dept表的主键id。</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references</span><br><span class="line">dept(id);</span><br><span class="line"></span><br><span class="line">#删除外键</span><br><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称</span><br><span class="line">#案例：删除emp表的外键fk_emp_dept_id。</span><br><span class="line">alter table emp drop foreign key fk_emp_dept_id;</span><br></pre></td></tr></table></figure>





<h2 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务不可分割，事务四大特性：</span><br><span class="line">原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</span><br><span class="line">一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</span><br><span class="line">隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立</span><br><span class="line">环境下运行。</span><br><span class="line">持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看/设置事务提交方式</span><br><span class="line">select @@autocommit;</span><br><span class="line">set @@autocommit=0;</span><br><span class="line"></span><br><span class="line">#开启事务 </span><br><span class="line">start transaction ; </span><br><span class="line">//beigin;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line">rollback</span><br></pre></td></tr></table></figure>





<h3 id="6-1-并发事务问题和解决"><a href="#6-1-并发事务问题和解决" class="headerlink" title="6.1 并发事务问题和解决"></a>6.1 并发事务问题和解决</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#并发事务问题</span><br><span class="line">1）脏读：一个事务读到另一个事务还没有提交的数据。</span><br><span class="line">2）不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</span><br><span class="line">3）幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#解决</span><br><span class="line">#事务隔离级别是用来解决事务并发问题的。</span><br><span class="line">| 隔离级别                     | 脏读 | 不可重复读 | 幻读 |</span><br><span class="line">| ---------------------------- | ---- | ---------- | ---- |</span><br><span class="line">| read uncommitted             | √    | √          | √    |</span><br><span class="line">| read committed（oracle默认） | ×    | √          | √    |</span><br><span class="line">| repeatable read （mysql默认) | ×    | ×          | √    |</span><br><span class="line">| serializable                 | ×    | ×          | ×    |</span><br><span class="line"></span><br><span class="line">#查看事务隔离级别</span><br><span class="line">select @@transaction_isolation;</span><br><span class="line"># 设置事务隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted ;</span><br><span class="line">set session transaction isolation level repeatable read ;</span><br><span class="line">//注意：事务的隔离级别越高，数据越安全，但是性能越低。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="7-Mysql存储引擎"><a href="#7-Mysql存储引擎" class="headerlink" title="7.Mysql存储引擎"></a>7.Mysql存储引擎</h2><h3 id="7-1-体系结构"><a href="#7-1-体系结构" class="headerlink" title="7.1 体系结构"></a>7.1 体系结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#连接层</span><br><span class="line">主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程</span><br><span class="line">池的概念，为通过认证安全接入的客户端提供线程</span><br><span class="line"></span><br><span class="line">#服务层</span><br><span class="line">SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等</span><br><span class="line"></span><br><span class="line">#引擎层  索引所在层</span><br><span class="line">负责了MySQL中数据的存储和提取</span><br><span class="line"></span><br><span class="line">#存储层</span><br><span class="line">主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询</span><br><span class="line">日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互</span><br></pre></td></tr></table></figure>



<h3 id="7-2-存储引擎："><a href="#7-2-存储引擎：" class="headerlink" title="7.2 存储引擎："></a>7.2 存储引擎：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。</span><br><span class="line">#建表时指定存储引擎</span><br><span class="line">create table xxx () engine=MyISM;</span><br><span class="line">#查询当前数据库支持的存储引擎</span><br><span class="line">show engines</span><br><span class="line"></span><br><span class="line">#InnoDB：MySql 5.5之后的   高可靠性和高性能。</span><br><span class="line">//DML,ACID，支持事务</span><br><span class="line">//行级锁</span><br><span class="line">//支持外键</span><br><span class="line"></span><br><span class="line">#xxx.ibd 表空间文件。表结构（frm,sdi)，数据和索引</span><br><span class="line">参数：innodb_file_per_table</span><br></pre></td></tr></table></figure>





<h2 id="8-索引"><a href="#8-索引" class="headerlink" title="8. 索引"></a>8. 索引</h2><p>定义：高效获取数据的数据结构（有序）。其中：无索引，全表扫描。有索引，走二叉树扫描。</p>
<h3 id="8-1-B-Tree索引"><a href="#8-1-B-Tree索引" class="headerlink" title="8.1 B+Tree索引"></a>8.1 B+Tree索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//B树</span><br><span class="line">B树是一种多叉路衡查找树.</span><br><span class="line">每个结点的值严格小于度数。以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针.</span><br><span class="line"></span><br><span class="line">//B+树</span><br><span class="line">B+Tree 与 B-Tree相比，主要有以下三点区别： </span><br><span class="line">所有的数据都会出现在叶子节点。 </span><br><span class="line">叶子节点形成一个单向链表。 </span><br><span class="line">非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</span><br><span class="line">//Mysql中的B+数的叶子节点形成的是双向链表。数据存叶子节点。</span><br><span class="line"></span><br><span class="line">//为啥InnoDB存储引擎采用B+树</span><br><span class="line">A.相对于二叉树，层级更少，搜索效率高</span><br><span class="line">B.对于B树，无论是叶子节点还是非叶子节点，都会保存数据，这样导致页表（页表就是CPU中的缓存页表，有个置换算法）中存储的键值减少，指针也少，要保存大量数据，只能增加树的高度，IO次数（磁盘读写）多，导致性能降低。</span><br><span class="line">C. 相对Hash索引，B+tree支持范围匹配及排序操作；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//InnoDB主键索引的B+Tree高度为多高？</span><br><span class="line">一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。</span><br><span class="line">高度为2：</span><br><span class="line">n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</span><br><span class="line">1171* 16 = 18736</span><br><span class="line">也就是说，如果树的高度为2，则可以存储 18000 多条记录。</span><br><span class="line">高度为3：</span><br><span class="line">1171 * 1171 * 16 = 21939856</span><br><span class="line">也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</span><br></pre></td></tr></table></figure>



<h3 id="8-2-哈希索引"><a href="#8-2-哈希索引" class="headerlink" title="8.2 哈希索引"></a>8.2 哈希索引</h3><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p>
<p>结构：采用一定的哈希算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。hash冲突，采用链表解决。</p>
<h3 id="8-3-索引分类"><a href="#8-3-索引分类" class="headerlink" title="8.3 索引分类"></a>8.3 索引分类</h3><table>
<thead>
<tr>
<th>主键索引</th>
<th>针对于表中主键创建的索引</th>
<th>默认自动创建</th>
</tr>
</thead>
<tbody><tr>
<td>唯一索引</td>
<td>避免同一个表中的某数据列中的值重复</td>
<td>可以有多个</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词。而不是比较索引中的值</td>
<td>可以有多个</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>将数据与索引放到了一块，索引结构的叶子节点保存了行数据</th>
<th>必须有，而且有多个</th>
</tr>
</thead>
<tbody><tr>
<td>二级索引</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//聚集索引选取规则：</span><br><span class="line">如果存在主键，主键索引就是聚集索引。</span><br><span class="line">如果不存在主键，将使用第一个唯一索引作为聚集索引</span><br><span class="line">如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成kowid作为隐藏的聚集索引。</span><br><span class="line"></span><br><span class="line">//聚集索引和二级索引的区别：</span><br><span class="line">聚集索引的叶子节点下挂的是这一行的数据</span><br><span class="line">二级索引的叶子节点下挂的是该字段值对应的主键值（聚集索引的主键值，然后再回表查询）。</span><br></pre></td></tr></table></figure>



<h3 id="8-4-覆盖索引"><a href="#8-4-覆盖索引" class="headerlink" title="8.4 覆盖索引"></a>8.4 覆盖索引</h3><p>尽量使用覆盖索引，减少select * </p>
<p>覆盖索引指的是查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。（就是select紧跟着的那些字段，在where之后的字段或者是在索引那（这时候走二级索引和聚集索引）那可以找到，这种就是覆盖索引）</p>
<table>
<thead>
<tr>
<th>using index condition</th>
<th>查找使用了索引，但是需要回表查询数据</th>
</tr>
</thead>
<tbody><tr>
<td>using where ;using index:</td>
<td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对</span><br><span class="line">以下SQL语句进行优化, 该如何进行才是最优方案:</span><br><span class="line">select id,username,password from tb_user where username =&#x27;itcast&#x27;;</span><br><span class="line"></span><br><span class="line">答案: 针对于 username, password建立联合索引, sql为: create index</span><br><span class="line">idx_user_name_pass on tb_user(username,password);</span><br><span class="line">这样可以避免上述的SQL语句，在查询的过程中，出现回表查询</span><br></pre></td></tr></table></figure>



<h3 id="8-5-前缀索引"><a href="#8-5-前缀索引" class="headerlink" title="8.5 前缀索引"></a>8.5 前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext等）时，，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_xxxx on table_name(column(n)) ;</span><br><span class="line">#为tb_user表的email字段，建立长度为5的前缀索引</span><br><span class="line">create index ide_email_5 on tb_user(email(5))</span><br></pre></td></tr></table></figure>



<h3 id="8-6-单列索引与联合索引"><a href="#8-6-单列索引与联合索引" class="headerlink" title="8.6 单列索引与联合索引"></a>8.6 单列索引与联合索引</h3><p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<h3 id="8-7-索引使用"><a href="#8-7-索引使用" class="headerlink" title="8.7 索引使用"></a>8.7 索引使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">基本使用</span><br><span class="line"></span><br><span class="line">#创建索引</span><br><span class="line">create [unique|fulltext] index index_name on table_name (index_col_name,...);</span><br><span class="line"></span><br><span class="line">#查看索引</span><br><span class="line">show  index from table_name;</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line">drop index index_name on table_name;</span><br><span class="line"></span><br><span class="line">#案例：为profession、age、status创建联合索引。</span><br><span class="line">create index idx_pro_age_sta on table_user(professional,age,status);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">验证索引效率</span><br><span class="line"></span><br><span class="line">//在未建立索引之前，执行如下SQL语句，查看耗时</span><br><span class="line">select * from tb_sku where sn=&quot;xxxx&quot;;</span><br><span class="line"></span><br><span class="line">#再创建索引</span><br><span class="line">create index idx_sku_sn on tb_sku(sn);</span><br><span class="line"></span><br><span class="line">#再执行语句查看耗时</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">索引提示</span><br><span class="line"></span><br><span class="line">//那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于 MySQL的SQL提示来完成。 接下来，介绍一下SQL提示。</span><br><span class="line">//use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</span><br><span class="line">explain select * from tb_user use index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">//ignore index ： 忽略指定的索引。</span><br><span class="line">explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br><span class="line"></span><br><span class="line">//force index ： 强制使用索引。</span><br><span class="line">explain select * from tb_user force index(idx_user_pro) where profession = &#x27;软件工</span><br><span class="line">程&#x27;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>





<h3 id="8-8-索引失效情况"><a href="#8-8-索引失效情况" class="headerlink" title="8.8 索引失效情况"></a>8.8 索引失效情况</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1.不遵守最左前缀法则</span><br><span class="line">最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</span><br><span class="line">联合索引 profession ,age,status ，要求profession必须存在。</span><br><span class="line">abc 中如果是ac这种是索引部分失效（还是走索引的，只有bc这种情况不走索引）</span><br><span class="line">注意：</span><br><span class="line"> 如果跳过之前的，那么走全表扫描。</span><br><span class="line"> 如果联合索引的字段都有也是走索引的，会进行优化。索引长度正常。</span><br><span class="line"></span><br><span class="line"># 2.范围查询</span><br><span class="line">联合索引中，出现范围查询(&lt;,&gt;) 范围查询右侧的列索引失效。如果包含等于，则不会。</span><br><span class="line"></span><br><span class="line">#3. 进行运算</span><br><span class="line">不要在索引上进行运算操作，例如加substring索引将失效。</span><br><span class="line"></span><br><span class="line">#4.字符串不加引号</span><br><span class="line">字符串类型字段使用时，不加引号，索引将失效。</span><br><span class="line"></span><br><span class="line">#5.头部模糊查询</span><br><span class="line">如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效。</span><br><span class="line"></span><br><span class="line">#6. or连接的条件（只有两侧都有才可以）</span><br><span class="line">用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</span><br></pre></td></tr></table></figure>





<h3 id="8-9-索引设计原则"><a href="#8-9-索引设计原则" class="headerlink" title="8.9 索引设计原则"></a>8.9 索引设计原则</h3><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立联合索引，而非单列索引。//如果多个字段，只会走一个索引，其余的会回表查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1). 针对于数据量较大，且查询比较频繁的表建立索引。</span><br><span class="line">2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</span><br><span class="line">3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</span><br><span class="line">4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</span><br><span class="line">5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，</span><br><span class="line">避免回表，提高查询效率。</span><br><span class="line">6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</span><br><span class="line">7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</span><br></pre></td></tr></table></figure>



<h1 id="9-SQL性能分析"><a href="#9-SQL性能分析" class="headerlink" title="9 SQL性能分析"></a>9 SQL性能分析</h1><h2 id="9-1-SQL执行频率"><a href="#9-1-SQL执行频率" class="headerlink" title="9.1  SQL执行频率"></a>9.1  SQL执行频率</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global status like&#x27;Com________&#x27;;	</span><br><span class="line"></span><br><span class="line">//7个下划线，第一个无含义，后面是匹配6个字符比如select，delete</span><br><span class="line">//Com_insert: 插入次数</span><br><span class="line">//Com_select: 查询次数</span><br><span class="line">//Com_update: 更新次数</span><br></pre></td></tr></table></figure>



<h2 id="9-2-慢查询日志"><a href="#9-2-慢查询日志" class="headerlink" title="9.2 慢查询日志"></a>9.2 慢查询日志</h2><p>记录了所有执行时间超过指定参数（long_query_time默认10秒）的所有SQL语句的日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Mysql的慢查询日志默认没有开启，</span><br><span class="line">show variables like &#x27;slow_query_log&#x27;</span><br><span class="line"></span><br><span class="line">#如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</span><br><span class="line">#开启MySql慢查询日志查询开关</span><br><span class="line">show_query_log=1</span><br><span class="line">#设置慢日志的时间为2秒，SQL语句执行语句超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br><span class="line">//windows下修改：C:\ProgramData\MySQL\MySQL Server 8.0的my.ini</span><br><span class="line"></span><br><span class="line">//配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log</span><br><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">执行如下SQL语句 ：</span><br><span class="line">select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00sec select count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时 13.35sec</span><br></pre></td></tr></table></figure>



<h2 id="9-3-profile详情"><a href="#9-3-profile详情" class="headerlink" title="9.3 profile详情"></a>9.3 profile详情</h2><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗到哪里去了，通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@have_profiling;	//0表示没有开启开关。</span><br><span class="line">#默认profiling是关闭的，可以通过set语句在session/global级别开启profiling</span><br><span class="line">set profiling=1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">select * from tb_user;</span><br><span class="line">select * from tb_user where id = 1;</span><br><span class="line">select * from tb_user where name = &#x27;白起&#x27;;</span><br><span class="line">select count(*) from tb_sku;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//然后通过如下指令查看指令的执行耗时：</span><br><span class="line">#查看每一条SQL的耗时基本情况</span><br><span class="line">show profiles;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="line">show profile for query query_id</span><br><span class="line"></span><br><span class="line">#查看指定query_id的SQL语句CPU的使用情况</span><br><span class="line">show profile cpu for query query_id</span><br></pre></td></tr></table></figure>



<h2 id="9-4-explain"><a href="#9-4-explain" class="headerlink" title="9.4 explain"></a>9.4 explain</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//explain或者desc命令获取mysql如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序</span><br><span class="line">//直接在语句前加一个explain</span><br><span class="line">EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</span><br></pre></td></tr></table></figure>

<p>各字段含义：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select 查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下;id不同，值越大，越先执行）。</th>
</tr>
</thead>
<tbody><tr>
<td>select_type</td>
<td>表示select的类型，常见的取值有simple（简单表，即不适用表连接或者子查询），primary（主查询，即外层的查询），union（union中的第二个或者后面的查询语句），subquery（select/where之后包含了子查询)等。</td>
</tr>
<tr>
<td>type</td>
<td>表示连接类型，性能由好到差的连接类型为NULL,system,const,eq_ref,range,index,all。</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</td>
</tr>
<tr>
<td>rows</td>
<td>Mysql认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的</td>
</tr>
<tr>
<td>filtered</td>
<td>表示返回结果的行数占需读取行数的百分比，filtered的值越大越好.</td>
</tr>
</tbody></table>
<p>extra为null表示回表查询，为use index则使用了索引。</p>
<h1 id="10-SQL优化"><a href="#10-SQL优化" class="headerlink" title="10. SQL优化"></a>10. SQL优化</h1><h2 id="10-1-普通insert"><a href="#10-1-普通insert" class="headerlink" title="10.1 普通insert"></a>10.1 普通insert</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#批量插入</span><br><span class="line">Insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);</span><br><span class="line"></span><br><span class="line">#手动提交事务</span><br><span class="line">start transaction;</span><br><span class="line">insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);</span><br><span class="line">insert into tb_test values(4,&#x27;Tom&#x27;),(5,&#x27;Cat&#x27;),(6,&#x27;Jerry&#x27;);</span><br><span class="line">insert into tb_test values(7,&#x27;Tom&#x27;),(8,&#x27;Cat&#x27;),(9,&#x27;Jerry&#x27;);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">//主键顺序插入，性能要高于乱序插入</span><br><span class="line">主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3</span><br><span class="line">主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</span><br></pre></td></tr></table></figure>



<h2 id="10-2-大批量插入"><a href="#10-2-大批量插入" class="headerlink" title="10.2 大批量插入"></a>10.2 大批量插入</h2><p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用Mysql数据库提供的load指令进行插入。操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//客户端连接服务端时，加上参数 </span><br><span class="line">local-infile mysql –-local-infile -u root -p</span><br><span class="line">//在load时，主键顺序插入性能高于乱序插入</span><br><span class="line"></span><br><span class="line">//设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="line">set global local_infile = 1;</span><br><span class="line"></span><br><span class="line">//执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data local infile &#x27;/root/sql1.log&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ;</span><br></pre></td></tr></table></figure>





<h2 id="10-3-主键设计原则"><a href="#10-3-主键设计原则" class="headerlink" title="10.3 主键设计原则"></a>10.3 主键设计原则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">满足业务需求的情况下，尽量降低主键的长度。</span><br><span class="line">插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</span><br><span class="line">尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</span><br><span class="line">业务操作时，避免对主键的修改。</span><br></pre></td></tr></table></figure>



<h2 id="10-4-其他优化"><a href="#10-4-其他优化" class="headerlink" title="10.4 其他优化"></a>10.4 其他优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">order by优化</span><br><span class="line"></span><br><span class="line">//MySQL的排序，有两种方式：</span><br><span class="line">Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</span><br><span class="line">Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</span><br><span class="line"></span><br><span class="line">//order by默认不走索引。</span><br><span class="line">//创建索引：</span><br><span class="line">create index idx_user_age_phone_aa on tb_user(age,phone);</span><br><span class="line">//explain select id,age,phone from tb_user order by age; 走索引</span><br><span class="line">//explain select id,age,phone from tb_user order by age , phone; 走索引</span><br><span class="line"></span><br><span class="line">//explain select id,age,phone from tb_user order by age desc , phone desc ;走索引+反向扫描</span><br><span class="line"></span><br><span class="line">//一个降序一个升序情况：</span><br><span class="line">//explain select id,age,phone from tb_user order by age asc , phone desc ;  using filesort+using index</span><br><span class="line">//解决上述一个降序一个升序情况：</span><br><span class="line">create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);</span><br><span class="line">//explain select id,age,phone from tb_user order by age asc , phone desc ;  走索引</span><br><span class="line"></span><br><span class="line">//order by优化原则: </span><br><span class="line">A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。 （上述一个升序一个降序的有问题的那，age走了索引）</span><br><span class="line">B. 尽量使用覆盖索引。 </span><br><span class="line">C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。 </span><br><span class="line">D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//group by优化</span><br><span class="line">建立联合索引。这里group by 要满足最左前缀匹配原则。</span><br><span class="line"></span><br><span class="line">//count优化</span><br><span class="line">按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽 量使用 count(*)。</span><br><span class="line"></span><br><span class="line">//limit优化</span><br><span class="line">#覆盖索引加子查 询形式进行优化。</span><br><span class="line">select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;</span><br><span class="line"></span><br><span class="line">//update优化</span><br><span class="line">//行锁</span><br><span class="line">update course set name = &#x27;javaEE&#x27; where id = 1 ;</span><br><span class="line">//行锁升级为表锁</span><br><span class="line">update course set name = &#x27;SpringBoot&#x27; where name = &#x27;PHP&#x27; </span><br><span class="line">//InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 </span><br></pre></td></tr></table></figure>





<h1 id="11-视图"><a href="#11-视图" class="headerlink" title="11.视图"></a>11.视图</h1><p>视图是虚拟表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建</span><br><span class="line">CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [</span><br><span class="line">CASCADED | LOCAL ] CHECK OPTION ]</span><br><span class="line">//create or replace view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">查看创建视图语句：SHOW CREATE VIEW 视图名称;</span><br><span class="line">查看视图数据：SELECT * FROM 视图名称 ...... ;</span><br><span class="line">//show create view stu_v_1;</span><br><span class="line">//select * from stu_v_1;</span><br><span class="line">//select * from stu_v_1 where id &lt; 3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</span><br><span class="line">//create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;</span><br><span class="line"></span><br><span class="line">方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</span><br><span class="line">//alter view stu_v_1 as select id,name from student where id &lt;= 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...</span><br><span class="line">//drop view if exists stu_v_1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//视图是可以用来插入数据的</span><br><span class="line">create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;</span><br><span class="line">select * from stu_v_1;</span><br><span class="line">insert into stu_v_1 values(6,&#x27;Tom&#x27;);</span><br><span class="line">insert into stu_v_1 values(17,&#x27;Tom22&#x27;);</span><br><span class="line">//id为6和17的数据都是可以成功插入的。 但是我们执行查询，查询出</span><br><span class="line">来的数据，却没有id为17的记录。</span><br><span class="line">//可以根据视图的检查选项来进行插入，修改删除数据。</span><br></pre></td></tr></table></figure>





<h2 id="11-1检查选项和更新"><a href="#11-1检查选项和更新" class="headerlink" title="11.1检查选项和更新"></a>11.1检查选项和更新</h2><p>mysql提供了两个选项，CASCADED 和 LOCAL ，默认值为 CASCADED 。</p>
<p>1）CASCADED 级联</p>
<p>2）LOCAL 本地</p>
<p>视图行于基础表的行一对一。如果包含以下任何一项，则不可更新:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） </span><br><span class="line">DISTINCT </span><br><span class="line">GROUP BY </span><br><span class="line">HAVING </span><br><span class="line">UNION 或者 UNION ALL</span><br></pre></td></tr></table></figure>



<h2 id="11-2-视图作用"><a href="#11-2-视图作用" class="headerlink" title="11.2 视图作用"></a>11.2 视图作用</h2><p>简单 ，安全，数据独立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例：</span><br><span class="line">#为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽 手机号和邮箱两个字段</span><br><span class="line">create view tb_user_view as select id,name,profession,age,gender,status,createtime</span><br><span class="line">from tb_user;</span><br><span class="line">select * from tb_user_view;</span><br><span class="line"></span><br><span class="line">#查询每个学生所选修的课程（三张表联查），为了简化操作，定义一个视图</span><br><span class="line">create view tb_stu_course_view as select s.name student_name , s.no student_no ,</span><br><span class="line">c.name course_name from student s, student_course sc , course c where s.id =</span><br><span class="line">sc.studentid and sc.courseid = c.id;</span><br><span class="line"></span><br><span class="line">select * from tb_stu_course_view;</span><br></pre></td></tr></table></figure>





<h1 id="12-MySQL中的锁"><a href="#12-MySQL中的锁" class="headerlink" title="12.MySQL中的锁"></a>12.MySQL中的锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局锁：锁定数据库中的所有表。 </span><br><span class="line">表级锁：每次操作锁住整张表。 </span><br><span class="line">行级锁：每次操作锁住对应的行数据。</span><br></pre></td></tr></table></figure>



<h2 id="12-1全局锁"><a href="#12-1全局锁" class="headerlink" title="12.1全局锁"></a>12.1全局锁</h2><p>对整个数据库实例加锁，加锁后整个实例处于只读状态，后续事务提交语句会被阻塞。</p>
<p>典型使用场景：数据库的逻辑备份。对所有表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#加全局锁</span><br><span class="line">flush table with read lock;</span><br><span class="line"></span><br><span class="line">#数据备份</span><br><span class="line">mysqldump -uroot -p1234 itcast &gt;itcast.sql</span><br><span class="line"></span><br><span class="line">#释放锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">//在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致 性数据备份</span><br><span class="line">mysqldump --single-transaction -uroot –p123456 itcast &gt; itcast.sql</span><br></pre></td></tr></table></figure>





<h2 id="12-2-表级锁"><a href="#12-2-表级锁" class="headerlink" title="12.2 表级锁"></a>12.2 表级锁</h2><p>每次锁住操作整张表，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p>对于表级锁，主要分为以下三类： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表锁 </span><br><span class="line">元数据锁（meta data lock，MDL）</span><br><span class="line">意向锁</span><br></pre></td></tr></table></figure>



<h3 id="12-2-1-表锁"><a href="#12-2-1-表锁" class="headerlink" title="12.2.1 表锁"></a>12.2.1 表锁</h3><p>表锁，分为两类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表共享读锁（read lock） </span><br><span class="line">表独占写锁（write lock）</span><br><span class="line"></span><br><span class="line">//加锁：lock tables 表名... read/write</span><br><span class="line">// 释放锁：unlock tables / 客户端断开连接 </span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">读锁：lock tables score read; </span><br><span class="line">客户端一加读锁，不影响客户端二的读，但是会阻塞右侧客户端的写(update 这种会失败)</span><br><span class="line"></span><br><span class="line">写锁：lock tables score write;</span><br><span class="line">客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</span><br><span class="line"></span><br><span class="line">结论：读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</span><br></pre></td></tr></table></figure>



<h3 id="12-2-2-元数据锁"><a href="#12-2-2-元数据锁" class="headerlink" title="12.2.2 元数据锁"></a>12.2.2 元数据锁</h3><p>meta data lock ,简写MDL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MDL加锁过程是系统自动控制，无需显示使用。在访问一张表的时候会自动加上。表上有活动事务时，不可以对元数据（表结构）进行写入操作。</span><br><span class="line">MYSQL5.5中引入MDL,对表进行增删改查，加MDL读锁（共享），当对表结构变更，加MDL写锁（排他）</span><br></pre></td></tr></table></figure>

<p>常见的SQL操作时，所添加的元数据锁：</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read / write</td>
<td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、 delete、select … for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLUSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//演示说明：</span><br><span class="line">//当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是兼容的。</span><br><span class="line">#客户端一执行select * from score;此时加元数据共享锁，客户端二select * from score 加元数据共享锁，客户端二update score set math=88 where id=1 加元数据共享锁</span><br><span class="line"></span><br><span class="line">//当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁 （EXCLUSIVE），之间是互斥的</span><br><span class="line">客户端一执行select * from score,加元数据共享锁，</span><br><span class="line">客户端二alter table score add column java int; 此时是元数据排他锁，这个时候需要等元数据共享锁释放，耗时1min3sec</span><br><span class="line"></span><br><span class="line">//查看元数据锁的情况：</span><br><span class="line">select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;</span><br></pre></td></tr></table></figure>





<h3 id="12-2-3-意向锁"><a href="#12-2-3-意向锁" class="headerlink" title="12.2.3 意向锁"></a>12.2.3 意向锁</h3><p>为了避免DML在执行时，加的行锁和表锁冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分析</span><br><span class="line">首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁，</span><br><span class="line">当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低</span><br><span class="line">有了意向锁之后，</span><br><span class="line">客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</span><br><span class="line">而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了</span><br><span class="line"></span><br><span class="line">//分类</span><br><span class="line">意向共享锁(IS): </span><br><span class="line">由语句select ... lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥</span><br><span class="line">客户端一：select * from score where id=1 lock in share mode;加意向共享锁，此时客户端二加表的读锁lock tables score read;成功说明兼容</span><br><span class="line"></span><br><span class="line">//意向排他锁(IX): </span><br><span class="line">由insert、update、delete、select...for update添加 。与表锁共享 锁(read)及排他锁(write)都互斥，**意向锁之间不会互斥</span><br><span class="line">客户端一update score set math=66 where id=1;加意向排他锁，此时客户端二查询，lock tbales score read加表的读锁及写锁会阻塞</span><br><span class="line"></span><br><span class="line">//一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</span><br><span class="line">#可以通过以下SQL，查看意向锁及行锁的加锁情况：</span><br><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from</span><br><span class="line">performance_schema.data_locks;</span><br></pre></td></tr></table></figure>





<h2 id="12-3-行级锁"><a href="#12-3-行级锁" class="headerlink" title="12.3 行级锁"></a>12.3 行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p>
<p>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p>
<p>行级锁主要分为以下三类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行锁（Record Lock）：**锁定单个行记录的锁**，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持</span><br><span class="line">间隙锁（Gap Lock）：**锁定索引记录间隙（不含该记录）**，确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</span><br><span class="line">临键锁（Next-Key Lock）：**行锁和间隙锁组合**，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</span><br></pre></td></tr></table></figure>



<h3 id="12-3-1-行锁"><a href="#12-3-1-行锁" class="headerlink" title="12.3.1 行锁"></a>12.3.1 行锁</h3><p>InnoDB实现了以下两种类型的行锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共享锁（S）：</span><br><span class="line">允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</span><br><span class="line"> </span><br><span class="line">排他锁（X）：</span><br><span class="line">允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。（就是说锁定一行不让别的事务来动这一行，和其他的都互斥）</span><br></pre></td></tr></table></figure>

<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT（正常）</td>
<td>不加任何 锁</td>
<td></td>
</tr>
<tr>
<td>SELECT … LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在SELECT之后加LOCK IN SHARE MODE</td>
</tr>
<tr>
<td>SELECT … FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在SELECT之后加FOR UPDATE</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//演示说明：</span><br><span class="line">//默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读</span><br><span class="line"></span><br><span class="line">#可以通过以下SQL查看意向锁及行锁的加锁情况：</span><br><span class="line">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from</span><br><span class="line">performance_schema.data_locks;</span><br><span class="line"></span><br><span class="line">//解释：</span><br><span class="line">	普通的select语句，执行时，不会加锁。</span><br><span class="line">	select ...in share mode ，加共享锁，共享锁和共享锁之间兼容,	共享锁和排他锁之间互斥。(即客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行 数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互 斥。)</span><br><span class="line">	排他锁和排他锁互斥（当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更 新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互 斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。）</span><br><span class="line">	无索引行锁升级为表锁（在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。 然后在客户端二中更新id为3的记录，却不能直接执行，因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引， 此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。针对name字段建立索引，索引建立之后，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3 的数据时，更新成功，并未进入阻塞状态。 这样就说明，我们根据索引字段进行更新操作，就可以避 免行锁升级为表锁的情况。</span><br><span class="line">	</span><br><span class="line">//总结</span><br><span class="line">针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</span><br><span class="line">InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁。</span><br></pre></td></tr></table></figure>



<h3 id="12-3-2-间隙锁-amp-临键锁"><a href="#12-3-2-间隙锁-amp-临键锁" class="headerlink" title="12.3.2 间隙锁&amp;临键锁"></a>12.3.2 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁  </span><br><span class="line">#间隙锁不能插入中间的数据。</span><br><span class="line">id记录为1，3，8，查id=5的记录，优化为间隙锁，把8之前的数据都锁住，此时不能插入7</span><br><span class="line"></span><br><span class="line">//索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</span><br><span class="line">临建锁是等值查询age=3时，当遇到非唯一普通索引（age=3不止一个）时，如果最后一个值age=7不等于这个值age=3，则这个非等值age=7就是间隙锁，要查询的那个等值age=3就是临建锁(锁住3和3之前的间隙）。</span><br><span class="line"></span><br><span class="line">//索引上的范围查询(唯一索引)  会访问到不满足条件的第一个值为止。</span><br><span class="line">查&gt;=19,</span><br><span class="line">数据这时候分为</span><br><span class="line">[19]</span><br><span class="line">(19,25]</span><br><span class="line">(25,+∞]</span><br><span class="line">遇到11时继续走，遇到19加行锁，25的是临建锁（包含25和25之前的间隙），正无穷的临建锁（正无穷及之前的间隙）</span><br><span class="line"></span><br><span class="line">//注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。</span><br></pre></td></tr></table></figure>



<h1 id="13-日志"><a href="#13-日志" class="headerlink" title="13.日志"></a>13.日志</h1><h2 id="13-1错误日志："><a href="#13-1错误日志：" class="headerlink" title="13.1错误日志："></a>13.1错误日志：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//默认存放目录 /var/log/，默认的日志文件名为 mysqld.log</span><br><span class="line">#查看日志 位置：</span><br><span class="line">show variables like &#x27;%log_error%&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="13-2-二进制日志"><a href="#13-2-二进制日志" class="headerlink" title="13.2 二进制日志"></a>13.2 二进制日志</h2><p>记录了所有的DDL和DML，但是不包括查询语句。</p>
<p>作用：1.灾难时的数据恢复      2。MySQL的主从复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在MySQL8版本中，默认二进制日志是开启着 的，涉及到的参数如下：</span><br><span class="line">show variables like &#x27;%log_bin%&#x27;</span><br><span class="line"></span><br><span class="line">//参数说明：</span><br><span class="line">log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文 件名需要再该basename的基础上加上编号(编号从000001开始)。</span><br><span class="line">log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些</span><br></pre></td></tr></table></figure>



<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</p>
<table>
<thead>
<tr>
<th>日志格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>STATEMENT</td>
<td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在 日志文件中。</td>
</tr>
<tr>
<td>ROW</td>
<td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td>
</tr>
<tr>
<td>MIXED</td>
<td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会 自动切换为ROW进行记录。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%binlog_format%&#x27;</span><br><span class="line">//如果我们需要配置二进制日志的格式，只需要在 /etc/my.cnf 中配置 binlog_format 参数即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//查看</span><br><span class="line">//需要通过二进制日志查询工具mysqlbinlog来查看，具体语法：</span><br><span class="line">mysqlbinlog [ 参数选项 ] logfilename</span><br><span class="line">参数选项：</span><br><span class="line">-d 指定数据库名称，只列出指定的数据库相关操作。</span><br><span class="line">-o 忽略掉日志中的前n行命令。</span><br><span class="line">-v 将行事件(数据变更)重构为SQL语句</span><br><span class="line">-vv 将行事件(数据变更)重构为SQL语句，并输出注释信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">| 指令                                             | 含义                                                         |</span><br><span class="line">| ------------------------------------------------ | ------------------------------------------------------------ |</span><br><span class="line">| reset master                                     | 删除全部 binlog 日志，删除之后，日志编号，将 从 binlog.000001重新开始 |</span><br><span class="line">| purge master logs to &#x27;binlog.*&#x27;                  | 删除 * 编号之前的所有日志                                    |</span><br><span class="line">| purge master logs before &#x27;yyyy-mm-dd hh24:mi:ss&#x27; | 删除日志为 &quot;yyyy-mm-dd hh24:mi:ss&quot; 之前 产生的所有日志       |</span><br><span class="line"></span><br><span class="line">//也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</span><br><span class="line">show variables like &#x27;%binlog_expire_logs_seconds%&#x27;</span><br></pre></td></tr></table></figure>



<h2 id="13-3-查询日志"><a href="#13-3-查询日志" class="headerlink" title="13.3 查询日志"></a>13.3 查询日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//二进制日志不包含查询数据的SQL语句。默认情况下， 查询日志是未开启的。</span><br><span class="line">//可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：</span><br><span class="line"></span><br><span class="line">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启</span><br><span class="line">general_log=1</span><br><span class="line">#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log</span><br><span class="line">general_log_file=mysql_query.log</span><br><span class="line"></span><br><span class="line">//开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运 行后，该日志文件将会非常大。</span><br><span class="line"></span><br><span class="line">//慢查询日志</span><br><span class="line">//记录了所有执行时间超过参数long_query_time设置值并且扫描记录数不小于min_examined_row_limit的所有SQL语句的日志，默认未开启。需要开启则在在MySQL的配置文件 /etc/my.cnf 中配置如下参数：</span><br><span class="line">#慢查询日志</span><br><span class="line">slow_query_log=1</span><br><span class="line">#执行时间参数</span><br><span class="line">long_query_time=2</span><br><span class="line"></span><br><span class="line">//要记录管理语句以及不使用索引进行查找的查询，需要这样修改：</span><br><span class="line">#记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements =1</span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes = 1</span><br><span class="line">//注意：上述的所有参数配置完成后需要重启MySQL服务器才可以生效。</span><br></pre></td></tr></table></figure>





<h1 id="14-主从复制"><a href="#14-主从复制" class="headerlink" title="14.主从复制"></a>14.主从复制</h1><p>是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和猪数据库的数据保持一致。</p>
<h2 id="14-1-主从复制的原理"><a href="#14-1-主从复制的原理" class="headerlink" title="14.1 主从复制的原理"></a>14.1 主从复制的原理</h2><ul>
<li><p>MySql主库在事务提交时，会把数据变更作为事件记录在二进制日志Binlog中；</p>
</li>
<li><p>主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中（主库主动推送，如果是拉取主服务器压力太大），之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；</p>
</li>
<li><p>MySql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I/O线程和SQL线程跑着从库上；</p>
</li>
<li><p>当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，如下图所示。</p>
</li>
</ul>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_06.324e9265.png" alt="img"></p>
<h2 id="14-2-主库搭建"><a href="#14-2-主库搭建" class="headerlink" title="14.2 主库搭建"></a>14.2 主库搭建</h2><p>运行mysql主实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>在mysql的配置文件夹<code>/mydata/mysql-master/conf</code>中创建一个配置文件<code>my.cnf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch my.cnf</span><br></pre></td></tr></table></figure>

<p>修改配置文件my.cnf，配置信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=101 </span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mall-mysql-bin  </span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062  </span><br></pre></td></tr></table></figure>

<p>修改完配置后重启实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure>

<p>进入<code>mysql-master</code>容器中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-master /bin/bash</span><br></pre></td></tr></table></figure>

<p>在容器中使用mysql的登录命令连接到客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure>

<p>创建数据同步用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="14-3-从库搭建"><a href="#14-3-从库搭建" class="headerlink" title="14.3 从库搭建"></a>14.3 从库搭建</h2><p>运行mysql从实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root  \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>在mysql的配置文件夹<code>/mydata/mysql-slave/conf</code>中创建一个配置文件<code>my.cnf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch my.cnf</span><br></pre></td></tr></table></figure>

<p>修改配置文件my.cnf：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，同一局域网中需要唯一</span><br><span class="line">server_id=102</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span><br><span class="line">log-bin=mall-mysql-slave1-bin  </span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed  </span><br><span class="line">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span><br><span class="line">expire_logs_days=7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=mall-mysql-relay-bin  </span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1  </span><br><span class="line">## slave设置为只读（具有super权限的用户除外）</span><br><span class="line">read_only=1  </span><br></pre></td></tr></table></figure>



<p>修改完配置后重启实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure>





<h2 id="14-4-将主从数据库进行连接"><a href="#14-4-将主从数据库进行连接" class="headerlink" title="14.4 将主从数据库进行连接"></a>14.4 将主从数据库进行连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#连接到主数据库的mysql客户端，查看主数据库状态：</span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p>主数据库状态显示如下：</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_01.b7042da2.png" alt="img"></p>
<p>进入<code>mysql-slave</code>容器中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql-slave /bin/bash</span><br></pre></td></tr></table></figure>

<p>在容器中使用mysql的登录命令连接到客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure>

<p>在从数据库中配置主从复制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.6.132&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3307, master_log_file=&#x27;mall-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;  </span><br></pre></td></tr></table></figure>



<p>主从复制命令参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master_host：主数据库的IP地址；</span><br><span class="line">master_port：主数据库的运行端口；</span><br><span class="line">master_user：在主数据库创建的用于同步数据的用户账号；</span><br><span class="line">master_password：在主数据库创建的用于同步数据的用户密码；</span><br><span class="line">master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</span><br><span class="line">master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</span><br><span class="line">master_connect_retry：连接失败重试的时间间隔，单位为秒。</span><br></pre></td></tr></table></figure>



<p>查看主从同步状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>



<p>从数据库状态显示如下：</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_02.af0d3f94.png" alt="img"></p>
<p>开启主从同步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>查看从数据库状态发现已经同步：</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_03.f7bd494f.png" alt="img"></p>
<h2 id="14-5-主从复制测试"><a href="#14-5-主从复制测试" class="headerlink" title="14.5 主从复制测试"></a>14.5 主从复制测试</h2><p>在主实例中创建一个数据库mall</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_04.6405bafb.png" alt="img"></p>
<p>在从实例中查看数据库，发现也有一个<code>mall</code>数据库，可以判断主从复制已经搭建成功</p>
<p><img src="https://www.macrozheng.com/assets/mysql_master_slave_05.98946658.png" alt="img"></p>
<h1 id="15-分库分表"><a href="#15-分库分表" class="headerlink" title="15 .分库分表"></a>15 .分库分表</h1><p>将数据分散存储。</p>
<p><strong>分库</strong>：就是一个数据库分成多个数据库，部署到不同机器。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AicsnEw0OkZjCPjCqpkGq6P3waq8eJCSc2vwbfUuxvWK64RMMZqxD50Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>分表</strong>：就是一个数据库表分成多个表，将一些<strong>不常用的、数据较大或者长度较长的列</strong>拆分到另外一张表</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AMxvOPgTA6ALzw9k5mb2ribiaTIz7rkHEhouHiaFSm4erVEia814zUMzKuA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="15-1-拆分策略："><a href="#15-1-拆分策略：" class="headerlink" title="15.1 拆分策略："></a>15.1 拆分策略：</h2><p>垂直拆封和水平拆分。拆分的粒度分为分库和分表。</p>
<h3 id="15-1-1-垂直拆分"><a href="#15-1-1-垂直拆分" class="headerlink" title="15.1.1 垂直拆分"></a>15.1.1 垂直拆分</h3><p>1.垂直分库</p>
<p>以表为依据，根据业务将不同表拆分到不同库中</p>
<p>特点：</p>
<p>每个库的表结构不一样</p>
<p>每个库的数据也不一样</p>
<p>所有库的并集是全量数据</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AVSic0IicIW2He4dRg59PM9XlhlbFTfXS3VHuYia95LQjy2SF4Ke1kiblJA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>2.垂直分表</p>
<p>以字段为依据，根据字段属性将不同字段拆分到不同表中。</p>
<p>特点：</p>
<p>每个表的结果都不一样</p>
<p>每个表的数据也不一样，一般通过一列（主键/外键）关联</p>
<p>所有表的并集是全量数据</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8Aibxn3h0lyYFHVviaAmiaCvY9h0VKtwlZgvkpkPkibqD7dgzSibuzX2SWyicQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-1-4水平分库"><a href="#15-1-4水平分库" class="headerlink" title="15.1.4水平分库"></a>15.1.4水平分库</h3><p>将表的数据量切分到不同的数据库服务器上，每个服务器具有相同的库和表，只是表中的数据集合不一样。它可以有效的缓解单机单库的性能瓶颈和压力</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8A3e4RicicoH3aXicAFmia4yUHTV2BSNQ8lkh1JyhJnwfbNfHZgzu9QKTJeQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="15-1-5-水平分表"><a href="#15-1-5-水平分表" class="headerlink" title="15.1.5 水平分表"></a>15.1.5 水平分表</h3><p>如果一个表的数据量太大，可以按照某种规则（如<code>hash取模、range</code>），把数据切分到多张表去。</p>
<p>一张订单表，按<code>时间range</code>拆分如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpybw23NtqebDqeaO10PeN8AYYRhzKL5cfUxicYcz2tph0mDQVoPMC889aT72nLz2PyXB5PpBsronBg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 注解大全</title>
    <url>/2022/11/24/SpringBoot%E4%B8%8B%E7%9A%84Annotations/</url>
    <content><![CDATA[<p>参考1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/article/1772324</span><br></pre></td></tr></table></figure>



<p>参考2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/article/1921919</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>SpringBoot 注解</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础知识</title>
    <url>/2022/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="并发和并行："><a href="#并发和并行：" class="headerlink" title="并发和并行："></a>并发和并行：</h3><p>并发：两个任务共享时间段，比如令狐冲一个人刺瞎多人眼睛，速度很快看起来同时发生。（多线程只能并发）。</p>
<p>并行：两个任务同一时间发生，比如多人运动，这是真正意义上同时发生的。（进程之间可以并行）。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h4><p>要求栈s1，s2,实现队列的先进先出，因栈是先入后出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.入队：直接压入s1。</span><br><span class="line">2.出队：若s2不空，弹出s2栈顶元素；若空，把s1的所有元素全部弹出压入s2，（此时和元素原始顺序一致）再弹出s2的栈顶元素（删一个或者多个）。</span><br></pre></td></tr></table></figure>



<p>其余参考：<a href="http://topjavaer.cn/computer-basic/network.html#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">程序员大彬 (topjavaer.cn)</a></p>
]]></content>
      <tags>
        <tag>计算机基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下新建hexo博客</title>
    <url>/2022/11/09/windows%E4%B8%8B%E6%96%B0%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1-1-安装node-js"><a href="#1-1-安装node-js" class="headerlink" title="1.1 安装node.js"></a>1.1 安装node.js</h3><p>官网下载node.js，傻瓜式安装成功后使用cmd使用下列命令查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h3 id="1-2-安装hexo博客框架"><a href="#1-2-安装hexo博客框架" class="headerlink" title="1.2 安装hexo博客框架"></a>1.2 安装hexo博客框架</h3><p>cmd命令输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>验证下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v </span><br></pre></td></tr></table></figure>



<h3 id="1-3-使用hexo搭建博客"><a href="#1-3-使用hexo搭建博客" class="headerlink" title="1.3 使用hexo搭建博客"></a>1.3 使用hexo搭建博客</h3><p>在你想要创建的目标文件夹Bolg下新建myblogs文件夹，输入以下命令（Bolg和myblogs是自定义文件夹名）</p>
<p>然后在myblogs文件栏那cmd输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>之后输入启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>之后ctrl+c关闭。</p>
<h3 id="1-4-部署到GitHub上"><a href="#1-4-部署到GitHub上" class="headerlink" title="1.4 部署到GitHub上"></a>1.4 部署到GitHub上</h3><p>创建一个跟自己用户名相同的后缀为.github.io的仓库，注意这里必须要与用户名相同。下面是我的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsdlife</span><br><span class="line">/</span><br><span class="line">lsdlife.github.io</span><br></pre></td></tr></table></figure>

<p>之后cmd输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>然后找到myblogs文件夹下的 _config.yml 文件</p>
<p>文件末尾输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/lsdlife/lsdlife.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>然后cmd输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d推送</span><br></pre></td></tr></table></figure>



<h3 id="1-5-换主题"><a href="#1-5-换主题" class="headerlink" title="1.5 换主题"></a>1.5 换主题</h3><p>选择好主题 找到github的连接</p>
<p>在myblogs文件夹那 git bash here</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init </span><br><span class="line">git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid</span><br></pre></td></tr></table></figure>

<p>修改为中文，在myblogs文件夹下的 _config.yml 文件开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>



<p>成功之后cmd输入（git d是远程推送到github)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clean </span><br><span class="line">git g</span><br><span class="line">git d </span><br></pre></td></tr></table></figure>



<h3 id="1-6-遇到的问题"><a href="#1-6-遇到的问题" class="headerlink" title="1.6 遇到的问题"></a>1.6 遇到的问题</h3><p>主要是git和github登不上导致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error：spawn failed...  </span><br><span class="line"></span><br><span class="line">error: RPC failed； curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
